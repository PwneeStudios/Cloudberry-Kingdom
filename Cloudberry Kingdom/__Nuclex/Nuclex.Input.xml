<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Input</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Input.Devices.BufferedMouse">
            <summary>Mouse that buffers mouse events until Update() is called</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IMouse">
            <summary>Specializd input devices for mouse-like controllers</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IInputDevice">
            <summary>Generic input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IInputDevice.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.IInputDevice.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.IInputDevice.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.IInputDevice.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.IMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.#ctor">
            <summary>Initializes a new buffered mouse device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnWheelRotated(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.OnMouseMoved(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferWheelRotation(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.BufferCursorMovement(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.pressedButtons">
            <summary>Mouse buttons currently pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.wheelPosition">
            <summary>Cumulative position of the mouse wheel</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.x">
            <summary>X coordinate of the mouse cursor</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.y">
            <summary>Y coordinate of the mouse cursor</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.queuedEvents">
            <summary>Queued mouse events</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouse.EventType">
            <summary>Types of event the buffered mouse can queue</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.ButtonPress">
            <summary>A button has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.ButtonRelease">
            <summary>A button has been released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.WheelRotation">
            <summary>The mouse wheel has been rotated</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.Movement">
            <summary>The mouse cursor has been moved</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.EventType.Snapshot">
            <summary>A snapshot was taken at this point in time</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouse.MouseEvent">
            <summary>Stores the properties of a mouse event</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.ButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Creates a new mouse event for a button press</summary>
            <param name="button">Button that has been pressed</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.ButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Creates a new mouse event for a button release</summary>
            <param name="button">Button that has been released</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.WheelRotation(System.Single)">
            <summary>Creates a new mouse event for a mouse wheel rotation</summary>
            <param name="ticks">Number of ticks wheel has been rotated</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Movement(System.Single,System.Single)">
            <summary>Creates a new mouse event for a mouse cursor movement</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
            <returns>The new mouse event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Snapshot">
            <summary>Creates a new mouse event for a snapshot point</summary>
            <returns>The new mouse event</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.EventType">
            <summary>Type of the event</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Button">
            <summary>Mouse buttons that were pressed or released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Ticks">
            <summary>Number of ticks the mouse wheel was rotated</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.X">
            <summary>New X coordinate of the mouse</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouse.MouseEvent.Y">
            <summary>New Y coordinate of the mouse</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerEventArgs">
            <summary>Carries the arguments for the controller detection event</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgs.#ctor">
            <summary>Initializes a new argument container for keyboard/mouse input</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgs.#ctor(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Initializes a new argument container with a controller index</summary>
            <param name="playerIndex">Player whose controller was detected</param>
        </member>
        <member name="F:Nuclex.Input.ControllerEventArgs.playerIndex">
            <summary>Index of the detected controller</summary>
        </member>
        <member name="P:Nuclex.Input.ControllerEventArgs.PlayerIndex">
            <summary>Index of the controller on which a button was pressed</summary>
            <remarks>
              If this is null, the player pressed a button/key on his mouse/keyboard.
            </remarks>
        </member>
        <member name="T:Nuclex.Input.ControllerEventArgsTest">
            <summary>Unit tests for the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgsTest.TestDefaultConstructor">
            <summary>Verifies that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerEventArgsTest.TestPlayerIndexConstructor">
            <summary>Verifies that the PlayerIndex constructor is working</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector">
            <summary>Detects which controller the player is using</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.#ctor(Nuclex.Input.IInputService)">
            <summary>Initializes a new controller detector</summary>
            <param name="inputService">
              Input service the detector uses to find out the controller
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Start">
            <summary>Begins monitoring input devices</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Stop">
            <summary>Stops monitoring input devices</summary>
            <remarks>
              After the detection event was triggered once, this is automatically called.
              You do not need to explicitly call this unless you want to abort detection.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.OnControllerDetected(System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Fires the ControllerDetected event</summary>
            <param name="playerIndex">Event that will be fired</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.detected(System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Called when a key/button press has been detected</summary>
            <param name="playerIndex">Index of the player who pressed a key/button</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.subscribeAllEvents">
            <summary>Subscribes the detector to all input devices</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.unsubscribeAllEvents">
            <summary>Unsubscribes the detector from all input devices</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.inputService">
            <summary>Input service the detector uses to access the controllers</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.started">
            <summary>Whether the detection is currently running</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedKeyReporters">
            <summary>Currently subscribed key press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedMouseReporters">
            <summary>Currently subscribed mouse button press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.subscribedGamePadReporters">
            <summary>Currently subscribed game pad button press reporters</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.detectedDelegate">
            <summary>Delegate for the controllerDetected() method</summary>
        </member>
        <member name="E:Nuclex.Input.ControllerDetector.ControllerDetected">
            <summary>
              Called when the player pressed a button on one of the controllers
            </summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.DetectionDelegate">
            <summary>Reports the index of the player who pressed a key/button</summary>
            <param name="playerIndex">Reported player index</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.Reporter">
            <summary>Base class for key/button press reporters</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.Reporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.Reporter.Callback">
            <summary>Callback the reporter invokes on a button/key press</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetector.Reporter.PlayerIndex">
            <summary>Player index the reporter will provide to the callback</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.KeyReporter">
            <summary>Reports key presses on a keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.KeyReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new keyboard reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.KeyReporter.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Subscribable callback for a key press</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.MouseButtonReporter">
            <summary>Reports buttons pressed on a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.MouseButtonReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new mouse reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.MouseButtonReporter.MouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Subscribable callback for a mouse button press</summary>
            <param name="buttons">Mouse buttons that have been pressed</param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetector.GamePadButtonReporter">
            <summary>Reports buttons pressed on a game pad</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.GamePadButtonReporter.#ctor(Nuclex.Input.ControllerDetector.DetectionDelegate,System.Nullable{Nuclex.Input.ExtendedPlayerIndex})">
            <summary>Initializes a new game pad reporter</summary>
            <param name="callback">Callback the reporter uses to report</param>
            <param name="playerIndex">Player index the reporter will report</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetector.GamePadButtonReporter.ButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Subscribable callback for a game pad button press</summary>
            <param name="buttons">Game pad buttons that have been pressed</param>
        </member>
        <member name="T:Nuclex.Input.CollectionHelper">
            <summary>Provides helper methods for collections</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelper.GetIfExists``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Returns an item from a list if the index exists</summary>
            <typeparam name="ItemType">Type of the item that will be returned</typeparam>
            <param name="list">List the item will be taken from</param>
            <param name="index">Index from which the item will be taken</param>
            <returns>The item if the index existed, otherwise a default item</returns>
        </member>
        <member name="M:Nuclex.Input.CollectionHelper.DisposeItems``1(System.Collections.Generic.IList{``0})">
            <summary>Disposes all items in a list</summary>
            <typeparam name="ItemType">Type of item that will be disposed</typeparam>
            <param name="list">List containing the items that will be disposed</param>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest">
            <summary>Unit tests for the collection helper</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestGetIfExists">
            <summary>Verifies that the Contains() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestDisposeItems">
            <summary>Verifies that the DisposeItems() method is working correctly</summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest.Test">
            <summary>Test implementation of the IDisposable interface</summary>
        </member>
        <member name="T:Nuclex.Input.CollectionHelperTest.TestDisposable">
            <summary>Test implementation of the IDisposable interface</summary>
        </member>
        <member name="M:Nuclex.Input.CollectionHelperTest.TestDisposable.Dispose">
            <summary>Called to dispose the instance</summary>
        </member>
        <member name="F:Nuclex.Input.CollectionHelperTest.TestDisposable.DisposeCallCount">
            <summary>Number of times the Dispose() method has been called</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest">
            <summary>Unit tests for the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.Setup">
            <summary>Called once before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestConstructor">
            <summary>Verifies that the constructor of the class is working</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestMouseDetection">
            <summary>
              Verifies that the controller detector detects a mouse button press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestKeyboard">
            <summary>
              Verifies that the controller detector detects a keyboard key press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestChatPad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that the controller detector detects a chat pad key press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.TestGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that the controller detector detects a game pad button press
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.mockSubscriber">
            <summary>Creates a mocked subscriber for the controller detector</summary>
            <returns>The mocked subscriber</returns>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.detector">
            <summary>Controller detector being tested</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.inputManager">
            <summary>Mocked input manager used for unit testing</summary>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest.IControllerDetectorSubscriber">
            <summary>Subscriber for the events of the controller detector</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.IControllerDetectorSubscriber.ControllerDetected(System.Object,Nuclex.Input.ControllerEventArgs)">
            <summary>
              Called when the controller detector has discovered a controller on
              which a button has been pressed
            </summary>
            <param name="sender">Detector sending the event</param>
            <param name="arguments">
              Contains the index of the player whose controller changed its state
            </param>
        </member>
        <member name="T:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher">
            <summary>Matches controller event args to expected values</summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor">
            <summary>
              Initializes a new matcher for controller event arguments for the default
              player on a PC system
            </summary>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Initializes a new matcher for controller event arguments</summary>
            <param name="playerIndex">
              Index of the player to expect in the event arguments
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.#ctor(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Initializes a new matcher for controller event arguments</summary>
            <param name="playerIndex">
              Index of the player to expect in the event arguments
            </param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.DescribeTo(System.IO.TextWriter)">
            <summary>Generates a human-readable description of the matcher</summary>
            <param name="writer">Writer the description is written into</param>
        </member>
        <member name="M:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.Matches(System.Object)">
            <summary>Tests whether the provided object matches the expected state</summary>
            <param name="otherObject">Other object that will be checked</param>
            <returns>True if the other object matches the expected state</returns>
        </member>
        <member name="F:Nuclex.Input.ControllerDetectorTest.ControllerEventArgsMatcher.playerIndex">
            <summary>Player index the matcher is expecting</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest">
            <summary>Unit tests for the buffered keyboard class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferKeyPress">
            <summary>Verifies that key presses can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferKeyRelease">
            <summary>Verifies that key releases can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferCharacterEntry">
            <summary>Verifies that character entries can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboardTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboardTest.keyboard">
            <summary>Buffered keyboard being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard">
            <summary>Test implementation of a buffered keyboard</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard">
            <summary>Keyboard that buffers key presses until Update() is called</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IKeyboard">
            <summary>Specialized input device for keyboard-like controllers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.#ctor">
            <summary>Initialize a new buffered keyboard device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.OnCharacterEntered(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.BufferCharacterEntry(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.queuedEvents">
            <summary>Keyboard events waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.current">
            <summary>Current state of the keyboard</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.BufferedKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard.EventType">
            <summary>Types of event the buffered keyboard can queue</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.KeyPress">
            <summary>A key has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.KeyRelease">
            <summary>A key has been released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.Character">
            <summary>A character has been entered</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.EventType.Snapshot">
            <summary>A snapshot was taken at this point in time</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent">
            <summary>Stores the properties of a keyboard event</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.KeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Creates a new keyboard event for a key press</summary>
            <param name="key">Key that has been pressed</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.KeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Creates a new keyboard event for a key release</summary>
            <param name="key">Key that has been released</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.CharacterEntry(System.Char)">
            <summary>Creates a new keyboard event for an entered character</summary>
            <param name="character">Character that has been entered</param>
            <returns>The new keyboard event</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Snapshot">
            <summary>Creates a new keyboard event for a snapshot point</summary>
            <returns>The new keyboard event</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.EventType">
            <summary>Type of the event</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Key">
            <summary>The key that was pressed or released</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedKeyboard.KeyboardEvent.Character">
            <summary>The character that was entered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferKeyPress(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key press in the event queue</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferKeyRelease(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Records a key release in the event queue</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.BufferCharacterEntry(System.Char)">
            <summary>Records a character in the event queue</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedKeyboardTest.TestBufferedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber">
            <summary>Subscriber to the </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been pressed</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedKeyboardTest.IKeyboardSubscriber.CharacterEntered(System.Char)">
            <summary>Called when a character has been entered</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest">
            <summary>Unit tests for the buffered mouse class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferButtonPress">
            <summary>Verifies that button presses can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferButtonRelease">
            <summary>Verifies that button releases can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferMouseMovement">
            <summary>Verifies that mouse movements can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferWheelRotation">
            <summary>Verifies that mouse wheel rotations can be buffered</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouseTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.BufferedMouseTest.mouse">
            <summary>Buffered mouse being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse">
            <summary>Test implementation of a buffered mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferButtonPress(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button press in the event queue</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferButtonRelease(Nuclex.Input.MouseButtons)">
            <summary>Records a mouse button release in the event queue</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferWheelRotation(System.Single)">
            <summary>Records a mouse wheel rotation in the event queue</summary>
            <param name="ticks">Ticks the mouse wheel has been rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.BufferCursorMovement(System.Single,System.Single)">
            <summary>Records a mouse cursor movement in the event queue</summary>
            <param name="x">X coordinate the mouse cursor has been moved to</param>
            <param name="y">Y coordinate the mouse cursor has been moved to</param>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.BufferedMouseTest.TestBufferedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber">
            <summary>Subscriber to the events of a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.ButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Button which has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.ButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released</summary>
            <param name="buttons">Button which has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.Moved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.BufferedMouseTest.IMouseSubscriber.WheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter">
            <summary>Converts DirectInput joystick states into usable data</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.#ctor(SlimDX.DirectInput.Joystick)">
            <summary>Initializes a new DirectInput state converter</summary>
            <param name="joystick">Joystick for which the converter will be used</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.Convert(SlimDX.DirectInput.JoystickState@)">
            <summary>Converts a joystick state into an XNA game pad state</summary>
            <param name="joystickState">Joystick state that will be converted</param>
            <returns>The equivalent XNA game pad state</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.mapAxes(SlimDX.DirectInput.Joystick)">
            <summary>Maps the axes of the joystick</summary>
            <param name="joystick">Joystick for which axes are mapped</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.mapSliders(SlimDX.DirectInput.Joystick)">
            <summary>Maps the sliders of the joystick</summary>
            <param name="joystick">Joystick for which sliders are mapped</param>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.sliderReaders">
            <summary>Readers for the sliders in the order of thea axis enumeration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.axisReaders">
            <summary>Readers for the axes in the order of the slider enumeration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.availableAxes">
            <summary>Axes available on the joystick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.availableSliders">
            <summary>Sliders available on the joystick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.buttonCount">
            <summary>Number of buttons on the device</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.povCount">
            <summary>Number of PoV controllers on the device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.indexFromSlider(Nuclex.Input.Devices.ExtendedSliders)">
            <summary>Returns the slider index from a value in the slider enumeration</summary>
            <param name="slider">Slider enumeration values whose index will be returned</param>
            <returns>The index of the specified slider enumeration value</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.indexFromAxis(Nuclex.Input.Devices.ExtendedAxes)">
            <summary>Returns the axis index from a value in the axis enumeration</summary>
            <param name="axis">Axis enumeration values whose index will be returned</param>
            <returns>The index of the specified axis enumeration value</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.createAxisReader(SlimDX.DirectInput.Joystick,Nuclex.Input.Devices.ExtendedAxes,SlimDX.DirectInput.DeviceObjectInstance)">
            <summary>Creates an axis reader for the specified object</summary>
            <param name="joystick">Joystick providing the control object</param>
            <param name="axis">Axis a reader will be created for</param>
            <param name="control">Control description for the axis</param>
            <returns>A new axis reader for the specified axis</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.createSliderReader(SlimDX.DirectInput.Joystick,Nuclex.Input.Devices.ExtendedSliders,SlimDX.DirectInput.DeviceObjectInstance)">
            <summary>Creates a slider reader for the specified object</summary>
            <param name="joystick">Joystick providing the control object</param>
            <param name="slider">Slider a reader will be created for</param>
            <param name="control">Control description for the axis</param>
            <returns>A new slider reader for the specified axis</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.identifyAxis(SlimDX.DirectInput.ObjectAspect,System.Guid)">
            <summary>Identifies the specified axis in the ExtendedAxes enumeration</summary>
            <param name="aspect">Aspect describing the order of the control</param>
            <param name="typeGuid">GUID describing the type of control</param>
            <returns>The equivalent entry in the ExtendedAxes enumeration or 0</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.identifySlider(SlimDX.DirectInput.ObjectAspect,System.Guid)">
            <summary>Identifies the specified slider in the ExtendedSliders enumeration</summary>
            <param name="aspect">Aspect describing the order of the control</param>
            <param name="typeGuid">GUID describing the type of control</param>
            <returns>The equivalent entry in the ExtendedSliders enumeration or 0</returns>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.AvailableAxes">
            <summary>Bit mask of the axes available on the joystick</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.AvailableSliders">
            <summary>Bit mask of the sliders available on the joystick</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.SliderReaders">
            <summary>Readers for the sliders in the order of the enumeration</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.AxisReaders">
            <summary>Readers for the axes in the order of the enumeration</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.ButtonCount">
            <summary>Number of buttons on the device</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputConverter.PovCount">
            <summary>Number of PoV controllers on the device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.IAxisReader">
            <summary>Reads the state of an axis or compares states</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.IAxisReader.GetValue(SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="state">Joystick state the axis is taken from</param>
            <returns>The value of the axis in the joystick state</returns>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.AxisReader">
            <summary>Reads the state of an axis and normalizes it</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.AxisReader.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new axis reader</summary>
            <param name="min">Negative range of the axis</param>
            <param name="max">Positive range of the axis</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.AxisReader.GetValue(SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="state">Joystick state the axis is taken from</param>
            <returns>The value of the axis in the joystick state</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.AxisReader.Read(SlimDX.DirectInput.JoystickState@)">
            <summary>Reads the raw value from the joystick state</summary>
            <param name="state">Joystick state the value is read from</param>
            <returns>The raw value of the axis in the joystick state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.AxisReader.center">
            <summary>The centered position of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.AxisReader.min">
            <summary>Positive range of the axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.AxisReader.max">
            <summary>Negative range of the axis</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.IButtonReader">
            <summary>Reads the state of a button</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.IButtonReader.IsPressed(System.Boolean[])">
            <summary>Determines whether the specified button is pressed</summary>
            <param name="buttons">Array containing the state of all buttons</param>
            <returns>True if the specified button was pressed</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.IButtonReader.HasChanged(System.Boolean[],System.Boolean[])">
            <summary>
              Determines whether the state of the specified button has changed
              between two states
            </summary>
            <param name="previous">Previous state of the buttons</param>
            <param name="current">Current state of the buttons</param>
            <returns>True if the state of the button has changed</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.ButtonReader.#ctor(System.Int32)">
            <summary>Initializes a new button reader for the specified button</summary>
            <param name="buttonIndex">
              Index of the button the reader is initialized for
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.ButtonReader.IsPressed(System.Boolean[])">
            <summary>Determines whether the specified button is pressed</summary>
            <param name="buttons">Array containing the state of all buttons</param>
            <returns>True if the specified button was pressed</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.ButtonReader.HasChanged(System.Boolean[],System.Boolean[])">
            <summary>
              Determines whether the state of the specified button has changed
              between two states
            </summary>
            <param name="previous">Previous state of the buttons</param>
            <param name="current">Current state of the buttons</param>
            <returns>True if the state of the button has changed</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.ButtonReader.buttonIndex">
            <summary>Index of the button the reader is checking</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.IPovReader">
            <summary>Reads the state of a point-of-view controller</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.IPovReader.GetDirection(System.Int32[])">
            <summary>Retrieves the current direction of the PoV controller</summary>
            <param name="povs">PoV states the direction will be read from</param>
            <returns>The direction of the PoV controller</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.IPovReader.HasChanged(System.Int32[],System.Int32[])">
            <summary>
              Reports whether the state of the point-of-view controller has changed
            </summary>
            <param name="previous">Previous states of the PoV controllers</param>
            <param name="current">Current states of the PoV controllers</param>
            <returns>True if the state of the PoV controller has changed</returns>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.PovReader">
            <summary>Reads the state of a specified point-of-view controller</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.PovReader.#ctor(System.Int32)">
            <summary>Initializes a new PoV reader</summary>
            <param name="povIndex">Index of the PoV controller that will be read</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.PovReader.GetDirection(System.Int32[])">
            <summary>Retrieves the current direction of the PoV controller</summary>
            <param name="povs">PoV states the direction will be read from</param>
            <returns>The direction of the PoV controller</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.PovReader.HasChanged(System.Int32[],System.Int32[])">
            <summary>
              Reports whether the state of the point-of-view controller has changed
            </summary>
            <param name="previous">Previous states of the PoV controllers</param>
            <param name="current">Current states of the PoV controllers</param>
            <returns>True if the state of the PoV controller has changed</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.PovReader.povIndex">
            <summary>Index of the PoV controller that will be read</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.ISliderReader">
            <summary>Reads the state of a slider or compares states</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.ISliderReader.GetValue(SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the slider</summary>
            <param name="state">Joystick state the slider is taken from</param>
            <returns>The value of the slider in the joystick state</returns>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.SliderReader">
            <summary>Reads the state of a slider and normalized it</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.SliderReader.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Initializes a new slider reader</summary>
            <param name="index">Index of the slider in the array</param>
            <param name="min">Negative range of the slider</param>
            <param name="max">Positive range of the slider</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.SliderReader.GetValue(SlimDX.DirectInput.JoystickState@)">
            <summary>Retrieves the current value of the axis</summary>
            <param name="state">Joystick state the axis is taken from</param>
            <returns>The value of the axis in the joystick state</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverter.SliderReader.Read(SlimDX.DirectInput.JoystickState@)">
            <summary>Reads the raw value from the joystick state</summary>
            <param name="state">Joystick state the value is read from</param>
            <returns>The raw value of the axis in the joystick state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.SliderReader.Index">
            <summary>Index of the slider in the array</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.SliderReader.min">
            <summary>Minimum raw value of the slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverter.SliderReader.range">
            <summary>Total value range of the slider</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.VelocitySliderReader">
            <summary>Reads the value of a velocity slider</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.AccelerationSliderReader">
            <summary>Reads the value of an acceleration slider</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverter.ForceSliderReader">
            <summary>Reads the value of a force slider</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputConverterTest">
            <summary>Unit tests for the DirectInput data format converter</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.TestGamePadStateConversion">
            <summary>Verifies that the converter can build a game pad state</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.TestExtendedGamePadStateConversion">
            <summary>Verifies that the converter can build an extended game pad state</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputConverterTest.requireAttachedJoystick">
            <summary>Requires a joystick to be attached to the system</summary>
            <remarks>
              Requiring hardware for a unit test is a big no-no, but SlimDX' wrappers arent
              all based on funky interfaces, so there's no way to mock the darn thing.
              Adding another layer of abstraction would only mean having no test coverage
              for that layer of abstraction.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverterTest.directInput">
            <summary>DirectInput interface the game pad will be based on</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputConverterTest.joystick">
            <summary>DirectInput joystick that will be used for testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputGamePad">
            <summary>Interfaces with a game pad-like controller through DirectInput</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePad">
            <summary>Interfaces with an XBox 360 controller via XNA (XINPUT)</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IGamePad">
            <summary>Specialized input device for game pad-like controllers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.IGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.IGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ExtendedButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IGamePad.ExtendedButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Fires the ButtonPressed event</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Fires the ButtonReleased event</summary>
            <param name="buttons">Buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnExtendedButtonPressed(System.UInt64,System.UInt64)">
            <summary>Fires the ExtendedButtonPressed event</summary>
            <param name="buttons1">Button or buttons that have been pressed or released</param>
            <param name="buttons2">Button or buttons that have been pressed or released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePad.OnExtendedButtonReleased(System.UInt64,System.UInt64)">
            <summary>Fires the ButtonReleased event</summary>
            <param name="buttons1">Button or buttons that have been pressed or released</param>
            <param name="buttons2">Button or buttons that have been pressed or released</param>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ExtendedButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.GamePad.ExtendedButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.HaveEventSubscribers">
            <summary>Whether subscribers to the standard button events exist</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePad.HaveExtendedEventSubscribers">
            <summary>Whether subscribers to the extended button events exist</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.#ctor(SlimDX.DirectInput.Joystick,Nuclex.Input.CheckAttachedDelegate)">
            <summary>Initializes a new DirectInput-based game pad</summary>
            <param name="joystick">The DirectInput joystick this instance will query</param>
            <param name="checkAttachedDelegate">
              Delegate through which the instance can check if the device is attached
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.queryState">
            <summary>Tries to retrieve the current state of the input device</summary>
            <returns>True if the state was successfully retrieved</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.ensureSlotAvailable">
            <summary>
              Ensures that another slot if available in the joystick state queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.generateEvents(SlimDX.DirectInput.JoystickState,SlimDX.DirectInput.JoystickState)">
            <summary>Generates events for the changes between two states</summary>
            <param name="previous">Previous state for the comparison</param>
            <param name="current">Current state for the comparison</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.generateAllEvents(System.Boolean[],System.Boolean[])">
            <summary>Generates events for all 128 possible buttons</summary>
            <param name="previousButtons">Previous state of all buttons</param>
            <param name="currentButtons">Current state of all buttons</param>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePad.generateStandardEventsOnly(System.Boolean[],System.Boolean[])">
            <summary>Generates events only for the standard XNA buttons</summary>
            <param name="previousButtons">Previous state of all buttons</param>
            <param name="currentButtons">Current state of all buttons</param>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.joystick">
            <summary>The DirectInput joystick wrapped by this instance</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.checkAttachedDelegate">
            <summary>
              Delegate through which the instance can check if the device is attached
            </summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.currentlyAcquired">
            <summary>Whether the device should currently be in the acquired state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.states">
            <summary>The joystick states as provided by DirectInput</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePad.converter">
            <summary>Converts joystick states into game pad states</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.DirectInputGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.DirectInputGamePadTest">
            <summary>Unit tests for the DirectInput-based game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestName">
            <summary>Verifies that the Name method returns the correct result</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.TestAttached(System.Boolean)">
            <summary>Verifies that the IsAttached method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.isAttachedMock(SlimDX.DirectInput.Device)">
            <summary>Reports that a device is attached</summary>
            <param name="device">Not used</param>
            <returns>Always true</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.isNotAttachedMock(SlimDX.DirectInput.Device)">
            <summary>Reports that a device is not attached</summary>
            <param name="device">Not used</param>
            <returns>Always false</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.DirectInputGamePadTest.requireAttachedJoystick">
            <summary>Requires a joystick to be attached to the system</summary>
            <remarks>
              Requiring hardware for a unit test is a big no-no, but SlimDX' wrappers arent
              all based on funky interfaces, so there's no way to mock the darn thing.
              Adding another layer of abstraction would only mean having no test coverage
              for that layer of abstraction.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePadTest.directInput">
            <summary>DirectInput interface the game pad will be based on</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.DirectInputGamePadTest.joystick">
            <summary>DirectInput joystick that will be used for testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.ExtendedAxes">
            <summary>Available axes on a controller</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.X">
            <summary>X-axis, usually the left-right movement of a stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.Y">
            <summary>Y-axis, usually the forward-backward movement of a stick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.Z">
            <summary>Z-axis, often the throttle control</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.VelocityX">
            <summary>X-axis velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.VelocityY">
            <summary>Y-axis velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.VelocityZ">
            <summary>Z-axis velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AccelerationX">
            <summary>X-axis acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AccelerationY">
            <summary>Y-axis acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AccelerationZ">
            <summary>Z-axis acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.ForceX">
            <summary>X-axis force</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.ForceY">
            <summary>Y-axis force</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.ForceZ">
            <summary>Z-axis force</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.RotationX">
            <summary>X-axis rotation</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.RotationY">
            <summary>Y-axis rotation</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.RotationZ">
            <summary>Z-axis rotation (often called the rudder)</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularVelocityX">
            <summary>X-axis angular velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularVelocityY">
            <summary>Y-axis angular velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularVelocityZ">
            <summary>Z-axis angular velocity</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularAccelerationX">
            <summary>X-axis angular acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularAccelerationY">
            <summary>Y-axis angular acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.AngularAccelerationZ">
            <summary>Z-axis angular acceleration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.TorqueX">
            <summary>X-axis torque</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.TorqueY">
            <summary>Y-axis torque</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedAxes.TorqueZ">
            <summary>Z-axis torque</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.ExtendedGamePadState">
            <summary>Extended game pad state with additional buttons and axes</summary>
            <summary>Extended game pad state with additional buttons and axes</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.GetButton(System.Int32)">
            <summary>Retrieves the state of the specified button</summary>
            <param name="buttonIndex">
              Index of the button whose state will be retrieved
            </param>
            <returns>The state of the queried button</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.IsButtonDown(System.Int32)">
            <summary>Determines whether the specified button is pressed down</summary>
            <param name="buttonIndex">Button which will be checked</param>
            <returns>True if the specified button is pressed down</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.IsButtonUp(System.Int32)">
            <summary>Determines whether the specified button is up</summary>
            <param name="buttonIndex">Button which will be checked</param>
            <returns>True if the specified button is up</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.GetAxis(Nuclex.Input.Devices.ExtendedAxes)">
            <summary>Retrieves the state of the specified axis</summary>
            <param name="axis">Axis whose state will be retrieved</param>
            <returns>The state of the specified axis</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.GetSlider(Nuclex.Input.Devices.ExtendedSliders)">
            <summary>Retrieves the state of the specified slider</summary>
            <param name="slider">Slider whose state will be retrieved</param>
            <returns>The state of the specified slider</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.GetPov(System.Int32)">
            <summary>Retrieves the PoV controller of the specified index</summary>
            <param name="index">Index of the PoV controller that will be retrieved</param>
            <returns>The state of the PoV controller with the specified index</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.DpadFromPov(System.Int32)">
            <summary>Converts a PoV controller state into a directional pad state</summary>
            <param name="pov">PoV controller state that will be converted</param>
            <returns>The equivalent directional pad state</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.PovFromDpad(Microsoft.Xna.Framework.Input.GamePadDPad)">
            <summary>Converts a directional pad state into a PoV controller state</summary>
            <param name="dpad">Directional pad state that will be converted</param>
            <returns>The equivalent PoV controller pad state</returns>
            <remarks>
              Conflicting states (eg. directional pad 'down' and 'up' at the same time)
              are resolved as if the specific axis was neutral.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.ButtonsFromExtendedButtons(System.UInt64)">
            <summary>
              Converts an extended button bit mask into the XNA's own button mask
            </summary>
            <param name="extendedButtons1">Button bit mask that will be converted</param>
            <returns>Equivalent XNA button mask for the provided button bit mask</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.ExtendedButtonsFromButtons(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
              Converts XNA's own button mask into an extended button bit mask
            </summary>
            <param name="buttons">XNA button mask that will be converted</param>
            <returns>Equivalent extended button bit mask for the provided button mask</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ButtonOrder">
            <summary>
              Order in which the buttons in the extended state map to XNAs Buttons enumeration
            </summary>
            <remarks>
              Tested this with an XBox 360 game pad. An older game pad used a completely
              arbitrary order and there's no way to find out which button resembles what,
              so I'm hoping that the XBox 360's DirectInput driver sets an inofficial
              standard and others copy the order in which its buttons are listed.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.InternalGetButtons(System.UInt64@,System.UInt64@)">
            <summary>Internal helper method that retrieves the raw button states</summary>
            <param name="buttons1">State of the first 64 buttons</param>
            <param name="buttons2">State of the second 64 buttons</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.countBits(System.UInt32)">
            <summary>Returns the number of bits set in an unsigned integer</summary>
            <param name="value">Value whose bits will be counted</param>
            <returns>The number of bits set in the unsigned integer</returns>
            <remarks>
              Based on a trick revealed here:
              http://stackoverflow.com/questions/109023
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AvailableAxes">
            <summary>Axes for which this state provides values</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.X">
            <summary>State of the device's X axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Y">
            <summary>State of the device's Y axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Z">
            <summary>State of the device's Z axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.VelocityX">
            <summary>State of the device's X velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.VelocityY">
            <summary>State of the device's Y velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.VelocityZ">
            <summary>State of the device's Z velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AccelerationX">
            <summary>State of the device's X acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AccelerationY">
            <summary>State of the device's Y acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AccelerationZ">
            <summary>State of the device's Z acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ForceX">
            <summary>State of the device's X force axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ForceY">
            <summary>State of the device's Y force axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ForceZ">
            <summary>State of the device's Z force axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.RotationX">
            <summary>State of the device's X rotation axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.RotationY">
            <summary>State of the device's Y rotation axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.RotationZ">
            <summary>State of the device's Z rotation axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularVelocityX">
            <summary>State of the device's X angular velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularVelocityY">
            <summary>State of the device's Y angular velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularVelocityZ">
            <summary>State of the device's Z angular velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularAccelerationX">
            <summary>State of the device's X angular acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularAccelerationY">
            <summary>State of the device's Y angular acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AngularAccelerationZ">
            <summary>State of the device's Z angular acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.TorqueX">
            <summary>State of the device's X torque axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.TorqueY">
            <summary>State of the device's Y torque axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.TorqueZ">
            <summary>State of the device's Z torque axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ButtonCount">
            <summary>Number of buttons provided by the state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AvailableSliders">
            <summary>Sliders for which this state provides values</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Slider1">
            <summary>First slider, formerly the U-axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Slider2">
            <summary>Second slider, formerly the V-axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.VelocitySlider1">
            <summary>First velocity slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.VelocitySlider2">
            <summary>second velocity slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AccelerationSlider1">
            <summary>First acceleration slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.AccelerationSlider2">
            <summary>Second acceleration slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ForceSlider1">
            <summary>First force slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.ForceSlider2">
            <summary>Second force slider</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.PovCount">
            <summary>Number of point-of-view controllers in this state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Pov1">
            <summary>Position of the first point-of-view controller</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Pov2">
            <summary>Position of the second point-of-view controller</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Pov3">
            <summary>Position of the third point-of-view controller</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.Pov4">
            <summary>Position of the fourth point-of-view controller</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.buttonState1">
            <summary>Bitfield containing the first 64 buttons</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedGamePadState.buttonState2">
            <summary>Bitfield containing the last 64 buttons</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.#ctor(Nuclex.Input.Devices.ExtendedAxes,System.Single[],Nuclex.Input.Devices.ExtendedSliders,System.Single[],System.Int32,System.Boolean[],System.Int32,System.Int32[])">
            <summary>Initializes a new extended game pas state to the provided values</summary>
            <param name="availableAxes">Bit mask of the axes made available in the state</param>
            <param name="axes">
              Values of all 24 axes in the order they appear in the ExtendedAxes enumeration
            </param>
            <param name="availableSliders">Bit mask of the slider provided by the state</param>
            <param name="sliders">
              Values of all 8 sliders in the order they appear in the ExtendedSliders enumeration
            </param>
            <param name="buttonCount">Number of buttons provided by the state</param>
            <param name="buttons">State of all 128 buttons in the state</param>
            <param name="povCount">Number of Point-of-View controllers in the state</param>
            <param name="povs">State of all 4 Point-of-View controllers</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.#ctor(Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>
              Initializes a new extended game pad state from a standard game pad state
            </summary>
            <param name="gamePadState">
              Standard game pad state the extended game pad state is initialized from
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadState.#ctor(Nuclex.Input.Devices.DirectInputConverter,SlimDX.DirectInput.JoystickState@)">
            <summary>
              Initializes a new extended game pad state from a DirectInput joystick state
            </summary>
            <param name="converter">DirectInput converter used to fill the state</param>
            <param name="joystickState">
              Joystick state from which the extended game pad state will be built
            </param>
        </member>
        <member name="P:Nuclex.Input.Devices.ExtendedGamePadState.AxisCount">
            <summary>Number of available axes in this state</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.ExtendedGamePadState.SliderCount">
            <summary>Number of available sliders in this state</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.ExtendedGamePadStateTest">
            <summary>Unit tests for the extended game pad state container</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.DefaultConstructorCanBeUsed">
            <summary>
              Verifies that the default constructor of the game state class works
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstructorTakesOverAxisStates">
            <summary>
              Verifies that the axis mappings in the full constructor are working
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstructorTakesOverAxisCount">
            <summary>
              Verifies that the number of axes is taken over by the constructor
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstructorTakesOverSliderStates">
            <summary>
              Verifies that the slider mappings in the full constructor are working
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstructorTakesOverSliderCount">
            <summary>
              Verifies that the number of sliders is taken over by the constructor
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstuctorTakesOverButtonStates">
            <summary>
              Verifies that the button mappings in the full constructor are working
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ConstructorTakesOverPovControllerStates">
            <summary>
              Verifies that the PoV controller mappings in the full constructor are working
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.AccessingInvalidAxisCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid axis is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.AccessingInvalidSliderCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid slider is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.AccessingInvalidButtonsCausesException(System.Int32)">
            <summary>
              Verifies that an exception is thrown if an invalid button is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.InvalidPovIndexCausesException(System.Int32)">
            <summary>
              Verifies that an exception is thrown if an invalid PoV controller is accessed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.ExtendedGamePadStateCanBeConstructedFromGamePadState(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
              Verifies that an extended game pad state can be constructed from a normal
              XNA game pad state
            </summary>
            <param name="button">Button to test on the normal game pad state</param>
        </member>
        <member name="M:Nuclex.Input.Devices.ExtendedGamePadStateTest.CanConvertBetweeenDirectionalPadAndPov(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Verifies that directional pad states can be converted into PoV controller states
              and vice versa
            </summary>
            <param name="pov">PoV controll state</param>
            <param name="up">Whether up on the directional pad is being pressed</param>
            <param name="down">Whether down on the directional pad is being pressed</param>
            <param name="left">Whether left on the directional pad is being pressed</param>
            <param name="right">Whether right on the directional pad is being pressed</param>
        </member>
        <member name="T:Nuclex.Input.Devices.ExtendedSliders">
            <summary>Extended slider axes provided by a game pad or joystick</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Slider1">
            <summary>First additional axis (formerly called U-axis)</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Slider2">
            <summary>Second additional axis (formerly called V-axis)</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Velocity1">
            <summary>First extra velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Velocity2">
            <summary>Second extra velocity axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Acceleration1">
            <summary>First extra acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Acceleration2">
            <summary>Second extra acceleration axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Force1">
            <summary>First extra force axis</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.ExtendedSliders.Force2">
            <summary>Second extra force axis</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest">
            <summary>Unit tests for the game pad base class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestButtonPressedEvent">
            <summary>Verifies that the ButtonPressed event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestButtonReleasedEvent">
            <summary>Verifies that the ButtonReleased event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestExtendedButtonPressedEvent">
            <summary>Verifies that the ExtendedButtonPressed event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestExtendedButtonReleasedEvent">
            <summary>Verifies that the ExtendedButtonReleased event is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestHaveSubscribers">
            <summary>Verifies that the HaveSubscribers property</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestHaveExtendedSubscribers">
            <summary>Verifies that the HaveExtendedSubscribers property</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.mockSubscriber">
            <summary>Mocks a subscriber for the game pad</summary>
            <returns>The mocked subscriber</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.makeGamePadState(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Creates a game pad state with the specified button pressed</summary>
            <param name="pressedButton">Button that will be pressed down</param>
            <returns>The new game pad state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadTest.mockery">
            <summary>Creates dynamic interface-based mock objects</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.GamePadTest.testGamePad">
            <summary>Test implementation of a game pad</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber">
            <summary>Subscriber for the game pad's events</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad is pressed</summary>
            <param name="buttons">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ExtendedButtonPressed(System.UInt64,System.UInt64)">
            <summary>Called when an extended button on the game pad is pressed</summary>
            <param name="buttons1">Button or buttons that have been pressed</param>
            <param name="buttons2">Button or buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.IGamePadSubscriber.ExtendedButtonReleased(System.UInt64,System.UInt64)">
            <summary>Called when an extended button on the game pad is released</summary>
            <param name="buttons1">Button or buttons that have been released</param>
            <param name="buttons2">Button or buttons that have been released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadTest.TestGamePad">
            <summary>Implementation of a game pad for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.Update">
            <summary>Update the state of all input devices</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Triggers the ButtonPressed event</summary>
            <param name="buttons">Buttons that will be reported</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Triggers the ButtonReleased event</summary>
            <param name="buttons">Buttons that will be reported</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireExtendedButtonPressed(System.UInt64,System.UInt64)">
            <summary>Triggers the ExtendedButtonPressed event</summary>
            <param name="buttons1">First set of buttons that will be reported</param>
            <param name="buttons2">Second set of buttons that will be reported</param>
        </member>
        <member name="M:Nuclex.Input.Devices.GamePadTest.TestGamePad.FireExtendedButtonReleased(System.UInt64,System.UInt64)">
            <summary>Triggers the ExtendedButtonReleased event</summary>
            <param name="buttons1">First set of buttons that will be reported</param>
            <param name="buttons2">Second set of buttons that will be reported</param>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.HaveEventSubscribers">
            <summary>Whether subscribers to the standard button events exist</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.GamePadTest.TestGamePad.HaveExtendedEventSubscribers">
            <summary>Whether subscribers to the extended button events exist</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.GamePadButtonDelegate">
            <summary>Delegate use to report presses and releases of game pad buttons</summary>
            <param name="buttons">Button or buttons that have been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.ExtendedGamePadButtonDelegate">
            <summary>Delegate use to report presses and releases of game pad buttons</summary>
            <param name="buttons1">Button or buttons that have been pressed or released</param>
            <param name="buttons2">Button or buttons that have been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyDelegate">
            <summary>Delegate used to report key presses and releases</summary>
            <param name="key">Key that has been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.CharacterDelegate">
            <summary>Delegate used to report characters typed on a keyboard</summary>
            <param name="character">Character that has been typed</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseMoveDelegate">
            <summary>Delegate used to report movement of the mouse cursor</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseButtonDelegate">
            <summary>
              Delegate used to report a press or released of one or more mouse buttons
            </summary>
            <param name="buttons">Button or buttons that have been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseWheelDelegate">
            <summary>Delegate used to report a rotation of the mouse wheel</summary>
            <param name="ticks">Number of ticks the mouse wheel has been rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseButtonEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="button">Button that has been pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseWheelEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MouseMoveEventDelegate">
            <summary>Delegate used to report a mouse event</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate or the mouse cursor</param>
        </member>
        <member name="T:Nuclex.Input.Devices.IMouseMessageSource">
            <summary>
              Sends out notifications for intercepted window messages related to the mouse
            </summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IMouseMessageSource.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchDelegate">
            <summary>Delegate used to report touch actions</summary>
            <param name="id">ID of the distinct touch</param>
            <param name="position">Position the action occurred at</param>
        </member>
        <member name="T:Nuclex.Input.Devices.ITouchPanel">
            <summary>Specializd input devices for mouse-like controllers</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.ITouchPanel.GetState">
            <summary>Retrieves the current state of the touch panel</summary>
            <returns>The current state of the touch panel</returns>
        </member>
        <member name="E:Nuclex.Input.Devices.ITouchPanel.Pressed">
            <summary>Triggered when the user presses on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.ITouchPanel.Moved">
            <summary>Triggered when the user moves his touch on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.ITouchPanel.Released">
            <summary>Triggered when the user releases the screen again</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.ITouchPanel.MaximumTouchCount">
            <summary>Maximum number of simultaneous touches the panel supports</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.LeakyQueueTest">
            <summary>Unit tests for the queue with leaky encapsulation</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.DefaultConstructorCanBeUsed">
            <summary>
              Verifies that the constructor of the leaky queue is working
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.CapacityCanBePassedToConstructor">
            <summary>Verifies that the constructor accepting a capacity is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.InvalidCapacityInConstructorThrowsException">
            <summary>
              Ensures that an exception is thrown if a leaky queue is constructed with
              an invalid capacity
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.QueueBecomesEmptyAfterCallingClear">
            <summary>Verifies that the leaky queue can be cleared</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.CountPropertyMatchesNumberOfContainedItems">
            <summary>Verifies that the count property is working as expected</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.QueueReturnsItemsInFifoOrder">
            <summary>Verifies that the queue performs normal FIFO operations</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.ContainsMethodFindsSearchedItem">
            <summary>
              Verifies that the Contains() method can detect if an item is in the queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.ContainsMethodFindsNullItems">
            <summary>
              Verifies that the Contains() method also works on null items
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.DequeuingFromEmptyQueueCausesException">
            <summary>
              Verifies that an exception is thrown if you attempt to dequeue from an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.AdvancingHeadOfEmptyQueueCausesException">
            <summary>
              Verifies that an exception is thrown if you attempt to advance the head of
              an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.QueueCanEnsureCapacityForOneMoreSlot">
            <summary>
              Verifies that an queue is able to ensure that there's space for one more
              item in it
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.PeekInEmptyQueueThrowsException">
            <summary>
              Verifies that an exception is thrown if the user attempts to Peek() into
              an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.PeekDoesNotDequeueItem">
            <summary>
              Verifies that Peek() only looks at the oldest item in the queue but doesn't
              dequeue it
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.QueueHeadCanBeAdvanced">
            <summary>
              Verifies that the queue's head can be advanced
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.AdvancingHeadOnEmptyQueueCausesException">
            <summary>
              Verifies that an exception is thrown if the user attempts to advance
              the head of an empty queue
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.TailCanBeAdvancedWithoutQueueing">
            <summary>
              Verifies that an queue's tail can be advanced without actually putting
              items in the queue (required if enqueuing entails merely changing the state
              of an item slot in the queue.
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.HeadAndTailIndexCanBeQueried">
            <summary>
              Tests whether the head and tail indices in the queue can be retrieved
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.QueueCanBeConvertedIntoArray">
            <summary>
              Verifies that a queue can be turned into an array
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueueTest.InternallyWrappedQueueCanBeConvertedIntoArray">
            <summary>
              Verifies that a queue that is wrapped can be turned into an array
            </summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedGamePad">
            <summary>Code-controllable game pad for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.#ctor">
            <summary>Initializes a new mocked game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Press(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Presses the specified buttons on the game pad</summary>
            <param name="buttons">Buttons that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Press(System.Int32)">
            <summary>Presses the specified button on the game pad</summary>
            <param name="extendedButtonIndex">Index of the button that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Release(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Releases the specified buttons on the game pad</summary>
            <param name="buttons">Buttons that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Release(System.Int32)">
            <summary>Releases the specified button on the game pad</summary>
            <param name="extendedButtonIndex">Button that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveLeftThumbStick(System.Single,System.Single)">
            <summary>Moves the left thumb stick to the specified position</summary>
            <param name="x">X coordinate of the thumb stick's position</param>
            <param name="y">Y coordinate of the thumb stick's position</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveRightThumbStick(System.Single,System.Single)">
            <summary>Moves the right thumb stick to the specified position</summary>
            <param name="x">X coordinate of the thumb stick's position</param>
            <param name="y">Y coordinate of the thumb stick's position</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.PushLeftTrigger(System.Single)">
            <summary>Pushes the left analog trigger to the specified depth</summary>
            <param name="depth">Depth the left analog trigger will be pushed to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.PushRightTrigger(System.Single)">
            <summary>Pushes the right analog trigger to the specified depth</summary>
            <param name="depth">Depth the right analog trigger will be pushed to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveAxis(Nuclex.Input.Devices.ExtendedAxes,System.Single)">
            <summary>Moves an axis to the specified position</summary>
            <param name="axis">Axis that will be moved</param>
            <param name="position">
              Position the axis will be moved to in the range from -1.0 to +1.0
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MoveSlider(Nuclex.Input.Devices.ExtendedSliders,System.Single)">
            <summary>Moves a slider to the specified position</summary>
            <param name="slider">Slider that will be moved</param>
            <param name="position">
              Position the slider will be moved to in the range from 0.0 to 1.0
            </param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.MovePov(System.Int32,System.Int32)">
            <summary>Moves a PoV controller into the specified position</summary>
            <param name="index">Index of the PoV controller that will be moved</param>
            <param name="position">Position the PoV controller will be moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.generateEvents(Nuclex.Input.Devices.ExtendedGamePadState@,Nuclex.Input.Devices.ExtendedGamePadState@)">
            <summary>Generates events for any changes to the button states</summary>
            <param name="previous">Previous state of the game pad to compare against</param>
            <param name="current">Current state of the game pad</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.buildState">
            <summary>Constructs an extended game pad state from the current state</summary>
            <returns></returns>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.updateButtonStates(Microsoft.Xna.Framework.Input.Buttons,System.Boolean)">
            <summary>Updates the state of all buttons in the mask</summary>
            <param name="buttonMask">Mask of buttons that will be updated</param>
            <param name="state">New state the buttons will assume</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePad.enforceButtonCountAtLeast(System.Int32)">
            <summary>
              Throws an exception if less than the required number of buttons are available
            </summary>
            <param name="requiredCount">Required number of buttons</param>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.states">
            <summary>Snapshots of the game pad state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.current">
            <summary>Currently published game pad state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.buttonCount">
            <summary>Number of buttons available on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.buttonStates">
            <summary>Current state of the buttons on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.availableAxes">
            <summary>Axes available on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.axisStates">
            <summary>Current positions of all axes on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.availableSliders">
            <summary>Sliders available on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.sliderStates">
            <summary>Current setting of all sliders on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.povCount">
            <summary>Number of PoV controller available on the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedGamePad.povStates">
            <summary>Current state of all PoV controllers on the game pad</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.ButtonCount">
            <summary>Reported number of buttons on the mocked game pad</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.AvailableAxes">
            <summary>Reported axes on the mocked game pad</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.AvailableSliders">
            <summary>Reported sliders on the mocked game pad</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedGamePad.PovCount">
            <summary>Reported number of PoV controllers on the mocked game pad</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedGamePadTest">
            <summary>Unit tests for the mocked game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestGetExtendedState">
            <summary>Verifies that the GetExtendedState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestAttachAndDetach">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestMoveLeftThumbStick">
            <summary>Tests whether the left thumb stick can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestMoveRightThumbStick">
            <summary>Tests whether the right thumb stick can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestLeftTrigger">
            <summary>Verifies that the left trigger can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestRightTrigger">
            <summary>Verifies that the right trigger can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestButtons(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Verifies that the buttons on the game pad can be pressed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestExtendedButtons">
            <summary>Verifies that the extended buttons on the game pad can be pressed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestAxisMovement">
            <summary>Verifies that the extended axes on the game pad can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestSliderMovement">
            <summary>Verifies that the extended sliders on the game pad can be moved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestDirectionalPad(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Verifies that the directional pad can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.MovingInvalidAxisCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid axis is moved
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.MovingUnavailableAxisCausesException">
            <summary>
              Verifies that an exception is thrown if an unavailable axis is moved
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.MovingInvalidSliderCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid slider is moved
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.MovingUnavailableSliderCausesException">
            <summary>
              Verifies that an exception is thrown if an unavailable slider is moved
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.PressingInvalidButtonsCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid button is pressed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.ReleasingInvalidButtonsCausesException">
            <summary>
              Verifies that an exception is thrown if an invalid button is pressed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedGamePadTest.TestPovs(System.Int32)">
            <summary>Verifies that the extended sliders on the game pad can be moved</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboard">
            <summary>Code-controllable keyboard for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.#ctor">
            <summary>Initializes a new mocked keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Enter(System.Char)">
            <summary>Types the specified character on the keyboard</summary>
            <param name="character">Character that will be typed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Type(System.String)">
            <summary>Types the specified text on the keyboard</summary>
            <param name="text">Text that will be typed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Press(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Presses the specified key on the keyboard</summary>
            <param name="key">Key that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Release(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Releases the specified key on the keyboard</summary>
            <param name="key">Key that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboard.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboard.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboard.keyMap">
            <summary>Maps characters to the keys enumeration</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboardTest">
            <summary>Unit tests for the mocked keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestAttachAndDetach">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestName">
            <summary>Verifies that the mocked keyboard's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestPressKey">
            <summary>Verifies that key presses can be simulation</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestReleaseKey">
            <summary>Verifies that key releases can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestEnterCharacter">
            <summary>Verifies that character entries can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.TestTypeText">
            <summary>Verifies that text entries can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboardTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedKeyboardTest.keyboard">
            <summary>Buffered keyboard being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber">
            <summary>Subscriber to the </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been pressed</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedKeyboardTest.IKeyboardSubscriber.CharacterEntered(System.Char)">
            <summary>Called when a character has been entered</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouse">
            <summary>Code-controllable mouse for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.#ctor">
            <summary>Initializes a new window message based mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">X coordinate the mouse cursor will be moved to</param>
            <param name="y">Y coordinate the mouse cursor will be moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Press(Nuclex.Input.MouseButtons)">
            <summary>Presses a button on the mouse</summary>
            <param name="button">Button that will be pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Release(Nuclex.Input.MouseButtons)">
            <summary>Buffers a button release on the mouse</summary>
            <param name="button">Button that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.RotateWheel(System.Single)">
            <summary>Rotates the mouse wheel by the specified number of ticks</summary>
            <param name="ticks">Number of ticks the mouse wheel will be rotated</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouse.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouse.isAttached">
            <summary>Whether the game pad is attached</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouseTest">
            <summary>Unit tests for the mocked mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestAttachAndDetach">
            <summary>Verifies that the mouse can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestName">
            <summary>Verifies that the mocked mouse's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestPressButton">
            <summary>Verifies that button presses can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestReleaseButton">
            <summary>Verifies that button releases can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestMoveTo">
            <summary>Verifies that mouse movement can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.TestRotateWheel">
            <summary>Verifies that mouse wheel rotations can be simulated</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.mockSubscriber">
            <summary>Mocks a subscriber for the buffered keyboard</summary>
            <returns>A subscriber registered to the events of the keyboard</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouseTest.mockery">
            <summary>Creates dynamic mock objects for interfaces</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedMouseTest.mouse">
            <summary>Buffered mouse being tested</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber">
            <summary>Subscriber to the events of a mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.ButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Button which has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.ButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been released</summary>
            <param name="buttons">Button which has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.Moved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedMouseTest.IMouseSubscriber.WheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardStateHelper">
            <summary>Contains helper methods to modify an XNA KeyboardState</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.KeyboardStateHelper.#cctor">
            <summary>Initializes the static fields of the class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.KeyboardStateHelper.createAddPressedKeyDelegate">
            <summary>
              Creates a delegate for adding a pressed key to a keyboard state
            </summary>
            <returns>A delegate that can be used to add a pressed key</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.KeyboardStateHelper.createRemovePressedKeyDelegate">
            <summary>
              Creates a delegate for removing a pressed key from a keyboard state
            </summary>
            <returns>A delegate that can be used to remove a pressed key</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.KeyboardStateHelper.AddPressedKey">
            <summary>Adds a pressed key to a KeyboardState</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.KeyboardStateHelper.RemovePressedKey">
            <summary>Removes a pressed key from a KeyboardState</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardStateHelper.AddPressedKeyDelegate">
            <summary>Delegate for the KeyboardState.AddPressedKey() method</summary>
            <param name="keyboardState">KeyboardState that will be modified</param>
            <param name="key">Key that will be added to the pressed keys</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardStateHelper.RemovePressedKeyDelegate">
            <summary>Delegate for the KeyboardState.RemovePressedKey() method</summary>
            <param name="keyboardState">KeyboardState that will be modified</param>
            <param name="key">Key that will be removed from the pressed keys</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardStateHelperTest">
            <summary>Unit tests for the modifiable keyboard state</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.KeyboardStateHelperTest.TestAddPressedKey">
            <summary>Tests whether the AddPressedKey() performs as expected</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.KeyboardStateHelperTest.TestRemovedPressedKey">
            <summary>Tests whether the RemovePressedKey() performs as expected</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedTouchPanel">
            <summary>Code-controllable touch panel for unit testing</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchPanelBase">
            <summary>Common functionality for the touch input panel</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.GetState">
            <summary>Retrieves the current state of the touch panel</summary>
            <returns>The current state of the touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.OnPressed(System.Int32,Microsoft.Xna.Framework.Vector2@)">
            <summary>Fires the Pressed event when the touch screen received a press</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position the user is touching the screen at</param>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.OnMoved(System.Int32,Microsoft.Xna.Framework.Vector2@)">
            <summary>Fires the Moved event when the user moved on the touch screen</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position the user has moved his touch to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.OnReleased(System.Int32,Microsoft.Xna.Framework.Vector2@)">
            <summary>Fires the Released event when the user released the touch screen</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position at which the user has released the screen</param>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchPanelBase.GenerateEvents(Nuclex.Input.Devices.TouchState@,Nuclex.Input.Devices.TouchState@)">
            <summary>Checks two touch states for changes an generates events</summary>
            <param name="previous">Previous touch state that will be compared</param>
            <param name="touchState">New touch state events will be generated for</param>
        </member>
        <member name="E:Nuclex.Input.Devices.TouchPanelBase.Pressed">
            <summary>Triggered when the user presses on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.TouchPanelBase.Released">
            <summary>Triggered when the user moves his touch on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.TouchPanelBase.Moved">
            <summary>Triggered when the user releases the screen again</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.TouchPanelBase.MaximumTouchCount">
            <summary>Maximum number of simultaneous touches the panel supports</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.TouchPanelBase.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.TouchPanelBase.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.#ctor">
            <summary>Initializes a new mocked touch panel</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.GetState">
            <summary>Retrieves the current state of the touch panel</summary>
            <returns>The current state of the touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Attach">
            <summary>Attaches (connects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Detach">
            <summary>Detaches (disconnects) the game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Press(System.Int32,System.Single,System.Single)">
            <summary>Presses down on the touch panel at the specified location</summary>
            <param name="id">ID this touch can be tracked with</param>
            <param name="x">X coordinate at which the touch panel was pressed</param>
            <param name="y">Y coordinate at which the touch panel was pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Release(System.Int32)">
            <summary>Releases the touch with the specified id</summary>
            <param name="id">Id of the touch that will be released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.Move(System.Int32,System.Single,System.Single)">
            <summary>Moves an existing touch to a different location</summary>
            <param name="id">Id of the touch that will be moved</param>
            <param name="x">New X coordinate the touch moved to</param>
            <param name="y">New Y coordinate the touch moved to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.MockedTouchPanel.buildState">
            <summary>Builds a touch state from the current touches</summary>
            <returns>The currently mocked touches in a touch state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedTouchPanel.states">
            <summary>Snapshots of the touch panel state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedTouchPanel.current">
            <summary>Currently published touch panel state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedTouchPanel.isAttached">
            <summary>Whether the touch panel is currently attached</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.MockedTouchPanel.touchCollection">
            <summary>Collection of touch events for the next state being built</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedTouchPanel.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedTouchPanel.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.MockedTouchPanel.MaximumTouchCount">
            <summary>Maximum number of simultaneous touches the panel supports</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.MockedTouchPanelTest">
            <summary>Unit tests for the mocked touch panel</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoTouchPanel">
            <summary>Dummy touch input panel that acts as a placeholder</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanel.#ctor">
            <summary>Initializes a new touch panel dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanel.GetState">
            <summary>Retrieves the current state of the touch panel</summary>
            <returns>The current state of the touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanel.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanel.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoTouchPanel.Pressed">
            <summary>Triggered when the user presses on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoTouchPanel.Released">
            <summary>Triggered when the user moves his touch on the screen</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoTouchPanel.Moved">
            <summary>Triggered when the user releases the screen again</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoTouchPanel.MaximumTouchCount">
            <summary>Maximum number of simultaneous touches the panel supports</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoTouchPanel.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoTouchPanel.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoTouchPanelTest">
            <summary>Unit tests for the dummy touch panel</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestIsAttached">
            <summary>Verifies that the keyboard dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestName">
            <summary>Verifies that the keyboard dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestMaximumTouchCount">
            <summary>Verifies that the MaximumTouchCount property returns 0</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.TestEvents">
            <summary>Tests whether the no mouse class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.touchPanelPressed(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>Dummy subscriber for the touch panel Pressed event</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position the user is touching the screen at</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.touchPanelMoved(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>Dummy subscriber for the touch panel Moved event</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position the user has moved his touch to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoTouchPanelTest.touchPanelReleased(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>Dummy subscriber for the touch panel Released event</summary>
            <param name="id">ID of the touch</param>
            <param name="position">Position at which the user has released the screen</param>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchCollectionHelper">
            <summary>An XNA TouchCollection that can be modified</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelper.#cctor">
            <summary>Initializes the static fields of the class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelper.Clear(Microsoft.Xna.Framework.Input.Touch.TouchCollection@)">
            <summary>Removes all touch locations from the collection</summary>
            <param name="touchCollection">Touch collection that will be cleared</param>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelper.createLocationCountDelegate">
            <summary>
              Creates a delegate for setting the location count in a TouchCollection
            </summary>
            <returns>A delegate that can be used to change the location count</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelper.createAddTouchLocationDelegate">
            <summary>
              Creates a delegate for adding a touch location to a TouchCollection
            </summary>
            <returns>A delegate that can be used to add a touch location</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.TouchCollectionHelper.SetLocationCount">
            <summary>Sets the location count of a TouchCollection</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.TouchCollectionHelper.AddTouchLocation">
            <summary>Adds a touch location to a TouchCollection</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchCollectionHelper.SetLocationCountDelegate">
            <summary>Delegate for setting the TouchCollection's location count</summary>
            <param name="touchCollection">Collection whose location count will be set</param>
            <param name="locationCount">New location count</param>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchCollectionHelper.AddTouchLocationDelegate">
            <summary>Delegate for calling the TouchCollection's AddTouchLocation() method</summary>
            <param name="touchCollection">Collection the location will be added to</param>
            <param name="id">ID of the touch location</param>
            <param name="state">What happened at the touch location</param>
            <param name="x">X coordinate of the touch location</param>
            <param name="y">Y coordinate of the touch location</param>
            <param name="prevState">What happened at the previous touch location</param>
            <param name="prevX">Previous X coordinate of the touch location</param>
            <param name="prevY">Previous Y coordinate of the touch location</param>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchCollectionHelperTest">
            <summary>Unit tests for the touch collection helper</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelperTest.TestSetLocationCount">
            <summary>
              Tests whether the number of touch locations in the collection can be set
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelperTest.TestClear">
            <summary>Verifies that a touch collection can be cleared</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchCollectionHelperTest.TestAddTouchLocation">
            <summary>
              Verifies that touch location can be added to a touch collection
            </summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoGamePad">
            <summary>Dummy that takes the place of unfilled player slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.#ctor">
            <summary>Initializes a new game pad dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.NoGamePad.axes">
            <summary>Neutral axis states for the extended game pad state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.NoGamePad.sliders">
            <summary>Neutral slider states for the extended game pad state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.NoGamePad.buttons">
            <summary>Neutral button states for the extended game pad state</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.NoGamePad.povs">
            <summary>Neutral PoV controller states for the extended game pad state</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ExtendedButtonPressed">
            <summary>Called when one or more buttons on the game pad have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoGamePad.ExtendedButtonReleased">
            <summary>Called when one or more buttons on the game pad have been released</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoGamePadTest">
            <summary>Unit tests for the game pad dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestGetExtendedState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestIsAttached">
            <summary>Verifies that the game pad dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestName">
            <summary>Verifies that the game pad dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestEvents">
            <summary>Tests whether the no game pad class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.TestExtendedEvents">
            <summary>
              Tests whether the no game pad class' extended events can be subscribed
            </summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.button(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Dummy subscriber for the ButtonPressed/Released event</summary>
            <param name="buttons">Buttons that have been pressed/released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoGamePadTest.extendedButton(System.UInt64,System.UInt64)">
            <summary>Dummy subscriber for the ExtendedButtonPressed/Released event</summary>
            <param name="buttons1">First 64 buttons that have been pressed/released</param>
            <param name="buttons2">Second 64 buttons that have been pressed/released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.NoKeyboard">
            <summary>Dummy that takes the place of unfilled keyboard slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.#ctor">
            <summary>Initializes a new keyboard dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.NoKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoKeyboardTest">
            <summary>Unit tests for the keyboard dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestIsAttached">
            <summary>Verifies that the keyboard dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestName">
            <summary>Verifies that the keyboard dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.TestEvents">
            <summary>Tests whether the no keyboard class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.key(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Dummy subscriber for KeyPressed/Released events</summary>
            <param name="key">Key that has been pressed/released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoKeyboardTest.characterEntered(System.Char)">
            <summary>Dummy subscriber for the CharacterEntered event</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="T:Nuclex.Input.Devices.NoMouse">
            <summary>Dummy that takes the place on unfilled mouse slots</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.#ctor">
            <summary>Initializes a new mouse dummy</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.GetState">
            <summary>Retrieves the current state of the mouse</summary>
            <returns>The current state of the mouse</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouse.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseMoved">
            <summary>Fired when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseButtonPressed">
            <summary>Fired when one or more mouse buttons have been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseButtonReleased">
            <summary>Fired when one or more mouse buttons have been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.NoMouse.MouseWheelRotated">
            <summary>Fired when the mouse wheel has been rotated</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.NoMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.NoMouseTest">
            <summary>Unit tests for the dummy mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestConstructor">
            <summary>Verifies that the constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestIsAttached">
            <summary>Verifies that the keyboard dummy is not attached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestName">
            <summary>Verifies that the keyboard dummy's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestTakeSnapshot">
            <summary>Verifies that the TakeSnapshot() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestUpdate">
            <summary>Verifies that the Update() method works</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestMoveTo">
            <summary>Verifies that the MoveTo() method does nothing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.TestEvents">
            <summary>Tests whether the no mouse class' events can be subscribed</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseMoved(System.Single,System.Single)">
            <summary>Dummy subscriber for the MouseMoved event</summary>
            <param name="x">X coordinate of the mouse cursor</param>
            <param name="y">Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseButton(Nuclex.Input.MouseButtons)">
            <summary>Dummy subscriber for the MouseButtonPressed/Released event</summary>
            <param name="buttons">Buttons that have been pressed/released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.NoMouseTest.mouseWheel(System.Single)">
            <summary>Dummy subscriber for the MouseWheelRotated event</summary>
            <param name="ticks">Ticks the wheel has been rotated</param>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchPanelTest">
            <summary>Unit tests for the dummy touch panel</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchState">
            <summary>Stores the state of a touch panel</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchState.#ctor(System.Boolean,Microsoft.Xna.Framework.Input.Touch.TouchCollection)">
            <summary>Initializes a new touch panel state</summary>
            <param name="isAttached">Whether the touch panel is connected</param>
            <param name="touches">Touch events since the last update</param>
        </member>
        <member name="F:Nuclex.Input.Devices.TouchState.isAttached">
            <summary>Whether the touch panel is connected</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.TouchState.touches">
            <summary>Collection of touches since the last update</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.TouchState.IsAttached">
            <summary>Whether the touch panel is connected</summary>
            <remarks>
              If the touch panel is not connected, all data in the state will
              be neutral
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.TouchState.Touches">
            <summary>Touch events that occured since the last update</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.TouchStateTest">
            <summary>Unit tests for the touch state</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchStateTest.TestAttachedProperty">
            <summary>Tests whether the attached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.TouchStateTest.TestTouchesProperty">
            <summary>Tests whether the touches property is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboard">
            <summary>Interfaces with a PC keyboard via window messages</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboard.#ctor(Nuclex.Input.Devices.IKeyboardMessageSource)">
            <summary>Initialize a new window message-based keyboard device</summary>
            <param name="messageSource">Source the window messages are obtained from</param>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboard.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferKeyPressDelegate">
            <summary>Delegate for the keyPressed() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferKeyReleaseDelegate">
            <summary>Delegate for the keyReleased() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.bufferCharacterEntryDelegate">
            <summary>Delegate for the characterEntered() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageKeyboard.messageSource">
            <summary>Window message source the instance is currently subscribed to</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboardTest">
            <summary>Unit tests for the window message based keyboard</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestIsAttached">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestName">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource">
            <summary>Dummy implementation of a keyboard message source</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.IKeyboardMessageSource">
            <summary>
              Sends out notifications for intercepted window messages related to the keyboard
            </summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.IKeyboardMessageSource.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageKeyboardTest.TestKeyboardMessageSource.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouse">
            <summary>Interfaces with a PC mouse via window messages</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.#ctor(Nuclex.Input.Devices.IMouseMessageSource)">
            <summary>Initializes a new window message based mouse</summary>
            <param name="messageSource">Source the window messages are obtained from</param>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouse.MoveTo(System.Single,System.Single)">
            <summary>Moves the mouse cursor to the specified location</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.buttonPressedDelegate">
            <summary>Delegate for the buttonPressed() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.buttonReleasedDelegate">
            <summary>Delegate for the buttonReleased() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.wheelRotatedDelegate">
            <summary>Delegate for the wheelRotated() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.cursorMovedDelegate">
            <summary>Delegate for the cursorMoved() method</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.WindowMessageMouse.messageSource">
            <summary>Window message source the instance is currently subscribed to</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageMouse.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.WindowMessageMouse.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouseTest">
            <summary>Unit tests for the window message based mouse</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouseTest.TestIsAttached">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouseTest.TestName">
            <summary>Verifies that the IsAttached property is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.WindowMessageMouseTest.TestMoveTo">
            <summary>Verifies that the MoveTo() method is working</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource">
            <summary>Dummy implementation of a mouse message source</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.WindowMessageMouseTest.TestMouseMessageSource.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePad">
            <summary>Interfaces with an XBox 360 controller via XNA (XINPUT)</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.#ctor(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Initializes a new XNA-based keyboard device</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.GetState">
            <summary>Retrieves the current state of the game pad</summary>
            <returns>The current state of the game pad</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.GetExtendedState">
            <summary>Retrieves the current DirectInput joystick state</summary>
            <returns>The current state of the DirectInput joystick</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePad.GenerateEvents(Microsoft.Xna.Framework.Input.GamePadState@,Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>Checks for state changes and triggers the corresponding events</summary>
            <param name="previous">Previous state of the game pad</param>
            <param name="current">Current state of the game pad</param>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.playerIndex">
            <summary>Index of the player this device represents</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.states">
            <summary>Snapshots of the game pad state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePad.current">
            <summary>Currently published game pad state</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaGamePad.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaGamePad.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePadTest">
            <summary>Unit tests for the XNA (XINPUT) game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.Setup">
            <summary>Called before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.Teardown">
            <summary>Called after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestGetExtendedState">
            <summary>Verifies that the GetExtendedState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestIsAttached">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestStateChangeDetection(Microsoft.Xna.Framework.Input.Buttons,System.Int32)">
            <summary>Tests whether state changes are detected by the game pad class</summary>
            <param name="button">Button that the detection will be tested with</param>
            <param name="extendedButtonIndex">Index of the button in the extended state</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.mockSubscriber">
            <summary>Mocks a subscriber for the game pad</summary>
            <returns>The mocked subscriber</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.makeGamePadState(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Creates a game pad state with the specified button pressed</summary>
            <param name="pressedButton">Button that will be pressed down</param>
            <returns>The new game pad state</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePadTest.mockery">
            <summary>Creates dynamic interface-based mock objects</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaGamePadTest.testGamePad">
            <summary>Test implementation of a game pad</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePadTest.IGamePadSubscriber">
            <summary>Subscriber for the game pad's events</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.IGamePadSubscriber.ButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad is pressed</summary>
            <param name="buttons">Button that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.IGamePadSubscriber.ButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Called when a button on the game pad has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.IGamePadSubscriber.ExtendedButtonPressed(System.UInt64,System.UInt64)">
            <summary>Called when an extended button on the game pad is pressed</summary>
            <param name="buttons1">Button or buttons that have been pressed</param>
            <param name="buttons2">Button or buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.IGamePadSubscriber.ExtendedButtonReleased(System.UInt64,System.UInt64)">
            <summary>Called when an extended button on the game pad is released</summary>
            <param name="buttons1">Button or buttons that have been released</param>
            <param name="buttons2">Button or buttons that have been released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaGamePadTest.TestGamePad">
            <summary>Implementation of a game pad for unit testing</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestGamePad.#ctor">
            <summary>Initializs a new test game pad</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaGamePadTest.TestGamePad.GenerateEvents(Microsoft.Xna.Framework.Input.GamePadState@,Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>Checks for state changes and triggers the corresponding events</summary>
            <param name="previous">Previous state of the game pad</param>
            <param name="current">Current state of the game pad</param>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaKeyboard">
            <summary>Interfaces with an XBox 360 chat pad via XNA (XINPUT)</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.characterMap">
            <summary>Maps the keys enumeration to characters</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.#ctor(Microsoft.Xna.Framework.PlayerIndex,Nuclex.Input.Devices.IGamePad)">
            <summary>Initializes a new XNA-based keyboard device</summary>
            <param name="playerIndex">Index of the player whose chat pad will be queried</param>
            <param name="gamePad">Game pad the chat pad is attached to</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.GetState">
            <summary>Retrieves the current state of the keyboard</summary>
            <returns>The current state of the keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.Update">
            <summary>Updates the state of the input device</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will take
                an immediate snapshot and make it the current state. This way, you
                can use the input devices without caring for the snapshot system if
                you wish.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.TakeSnapshot">
            <summary>Takes a snapshot of the current state of the input device</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyPressed event</summary>
            <param name="key">Key to report as having been pressed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyReleased event</summary>
            <param name="key">Key to report as having been releaed</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.OnCharacterEntered(System.Char)">
            <summary>Fires the CharacterEntered event</summary>
            <param name="character">Character to report as having been entered</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.getAllValidKeys">
            <summary>Returns all entries in the XNA Keys enumeration</summary>
            <returns>All entries in the keys enumeration</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.queryKeyboardState">
            <summary>Updates the immediate (non-buffered) state of the keyboard</summary>
            <remarks>
              Only called when the game is not using the Update() and TakeSnapshot() methods
              to buffer input.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.generateEvents(Microsoft.Xna.Framework.Input.KeyboardState@,Microsoft.Xna.Framework.Input.KeyboardState@)">
            <summary>Generates events for the differences between two states</summary>
            <param name="previous">Previous state the keyboard reported</param>
            <param name="current">Current state reported by the keyboard</param>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboard.generateCharacterEvent(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Generates the character entered event for the chat pad</summary>
            <param name="key">Key that has been pressed on the chat pad</param>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.validKeys">
            <summary>Contains all keys listed in the Keys enumeration</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.playerIndex">
            <summary>Index of the player this device represents</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.gamePad">
            <summary>Game pad the chat pad is attached to</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.states">
            <summary>Snapshots of the keyboard state waiting to be processed</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.XnaKeyboard.current">
            <summary>Currently published keyboard state</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.KeyPressed">
            <summary>Fired when a key has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.KeyReleased">
            <summary>Fired when a key has been released</summary>
        </member>
        <member name="E:Nuclex.Input.Devices.XnaKeyboard.CharacterEntered">
            <summary>Fired when the user has entered a character</summary>
            <remarks>
              This provides the complete, translated character the user has entered.
              Handling of international keyboard layouts, shift key, accents and
              other special cases is done by Windows according to the current users'
              country and selected keyboard layout.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaKeyboard.IsAttached">
            <summary>Whether the input device is connected to the system</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.XnaKeyboard.Name">
            <summary>Human-readable name of the input device</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.XnaKeyboardTest">
            <summary>Unit tests for the XNA (XINPUT) based chat pad class</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestGetState">
            <summary>Verifies that the GetState() method is working</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestIsAttached">
            <summary>Verifies that the game pad can be attached and detached</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.XnaKeyboardTest.TestName">
            <summary>Verifies that the mocked game pad's name can be retrieved</summary>
        </member>
        <member name="T:Nuclex.Input.CheckAttachedDelegate">
            <summary>Checks whether the specified device is attached</summary>
            <param name="device">Device that will be checked</param>
            <returns>True if the device is attached, false otherwise</returns>
        </member>
        <member name="T:Nuclex.Input.DirectInputManager">
            <summary>Manages DirectInput devices</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.#ctor(System.IntPtr)">
            <summary>Initializes a new DirectInput manager</summary>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.IsDeviceAttached(SlimDX.DirectInput.Device)">
            <summary>Whether the device is currently attached</summary>
            <param name="device">Device that will be checked</param>
            <returns>True if the device is attached, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.CreateGamePads">
            <summary>Creates game pad wrappers for all DirectInput game pads</summary>
            <returns>An array with wrappers for all DirectInput game pads</returns>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.isXInputDevice(SlimDX.DirectInput.DeviceInstance)">
            <summary>
              Determines whether the specified DirectInput device is handled by XINPUT
            </summary>
            <param name="deviceInstance">
              The DirectInput device instance that will be checked
            </param>
            <returns>True if this is a device that is handled by XINPUT</returns>
            <remarks>
              <para>
                XINPUT devices are accessable through both DirectInput and XINPUT.
                Since we're already using XINPUT (through XNA), we need to filter out
                any DirectInput devices that we already access through XINPUT, otherwise,
                each XINPUT game controller would appear twice.
              </para>
              <para>
                This method is based on the code from the ZMan's article on detecting
                which DirectInput devices are also XInput devices:
                http://www.thezbuffer.com/articles/351.aspx
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.DirectInputManager.tryExtractVidPid(System.String,System.Int32@,System.Int32@)">
            <summary>the USB VID and PID from a management object's DeviceID</summary>
            <param name="deviceId">DeviceID the USB IDs will be extracted from</param>
            <param name="vid">Output parameter that receives the VID</param>
            <param name="pid">Output parameter that receives the PID</param>
            <returns>True if the VID and PID were successfully extracted</returns>
        </member>
        <member name="F:Nuclex.Input.DirectInputManager.directInput">
            <summary>DirectInput instance used by the manager to query input devices</summary>
        </member>
        <member name="P:Nuclex.Input.DirectInputManager.IsDirectInputAvailable">
            <summary>
              Determines whether DirectInput is available on the current system
            </summary>
        </member>
        <member name="T:Nuclex.Input.DirectInputManagerTest">
            <summary>Unit tests for the DirectInput manager</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestIsDirectInputAvailable">
            <summary>Verifies that the IsDirectInputAvailable property is working</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestDispose">
            <summary>Tests whether the DirectInput manager can be disposed</summary>
        </member>
        <member name="M:Nuclex.Input.DirectInputManagerTest.TestCreateGamePadsAndIsDeviceAttached">
            <summary>Verifies that the IsDeviceAttached() method works</summary>
        </member>
        <member name="T:Nuclex.Input.ExtendedPlayerIndex">
            <summary>Player index enumeration with slots for 8 players</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.One">
            <summary>First player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Two">
            <summary>Second player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Three">
            <summary>Third player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Four">
            <summary>Fourth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Five">
            <summary>Fifth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Six">
            <summary>Sixth player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Seven">
            <summary>Seventh player</summary>
        </member>
        <member name="F:Nuclex.Input.ExtendedPlayerIndex.Eight">
            <summary>Eigth player</summary>
        </member>
        <member name="T:Nuclex.Input.GamePadButtonsHelper">
            <summary>Contains helper methods for the GamePadButtons enumeration</summary>
        </member>
        <member name="M:Nuclex.Input.GamePadButtonsHelper.Contains(Microsoft.Xna.Framework.Input.Buttons,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>Checks whether buttons are contained in a button flag field</summary>
            <param name="buttons">Button flag field that will be checked</param>
            <param name="button">Buttons for which the method will check</param>
            <returns>True if all specified buttons appear in the flag field</returns>
        </member>
        <member name="T:Nuclex.Input.GamePadButtonsHelperTest">
            <summary>Unit tests for the game pad buttons helper</summary>
        </member>
        <member name="M:Nuclex.Input.GamePadButtonsHelperTest.TestContains">
            <summary>Verifies that the Contains() method is working</summary>
        </member>
        <member name="T:Nuclex.Input.IInputService">
            <summary>Provides access to the game's input devices</summary>
            <remarks>
              This interface provides a uniform way to access all input devices available
              to the system. It also allows XNA games to interface with standard game pads
              and joysticks through DirectInput.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.GetTouchPanel">
            <summary>Returns the touch panel on the system</summary>
            <returns>The system's touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.IInputService.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.IInputService.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="P:Nuclex.Input.IInputService.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.TouchPanels">
            <summary>All touch panels known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.IInputService.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardKeyEventDelegate">
            <summary>Delegate used to report a keyboard event</summary>
            <param name="key">Key that was pressed or released</param>
        </member>
        <member name="T:Nuclex.Input.Devices.KeyboardCharacterEventDelegate">
            <summary>Delegate used to report a keyboard event</summary>
            <param name="character">Character that ha been entered</param>
        </member>
        <member name="T:Nuclex.Input.InputManager">
            <summary>Manages and polls input devices</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor">
            <summary>Initializes a new input manager</summary>
            <remarks>
              This overload is offered for convenience and takes the window handle
              from XNA's Mouse class. It will only work if your game is either based
              on the XNA Game class or if you assign the Mouse.WindowHandle
              property sourself.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(System.IntPtr)">
            <summary>Initializes a new input manager</summary>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>Initializs a new input manager</summary>
            <param name="services">Game service container the manager registers to</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer,System.IntPtr)">
            <summary>Initializs a new input manager</summary>
            <param name="services">Game service container the manager registers to</param>
            <param name="windowHandle">Handle of the game's main window</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.GetTouchPanel">
            <summary>Returns the touch panel on the system</summary>
            <returns>The system's touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.InputManager.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.InputManager.OnUpdateOrderChanged">
            <summary>Fires the UpdateOrderChanged event</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IGameComponent#Initialize">
            <summary>Only exists to implement IGameComponent</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IUpdateable#Update(Microsoft.Xna.Framework.GameTime)">
            <summary>Updates the state of all input devices</summary>
            <param name="gameTime">Not used</param>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupGamePads">
            <summary>Sets up the collection of available game pads</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupMouse">
            <summary>Sets up the collection of available mice</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupKeyboards">
            <summary>Sets up the collection of available keyboards</summary>
        </member>
        <member name="M:Nuclex.Input.InputManager.setupTouchPanels">
            <summary>Sets up the collection of available touch panels</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.directInputManager">
            <summary>Manages DirectInput, if DirectInput is installed</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.windowMessageFilter">
            <summary>Intercepts input-related messages to XNA's main window</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.gamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.mice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.keyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.touchPanels">
            <summary>Collection of all touch panels known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.snapshotCount">
            <summary>Number of state snap shots currently queued</summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.updateOrder">
            <summary>
              Controls the order in which this game component is updated relative
              to other game components.
            </summary>
        </member>
        <member name="F:Nuclex.Input.InputManager.gameServices">
            <summary>Game service container, saved to unregister on dispose</summary>
        </member>
        <member name="E:Nuclex.Input.InputManager.UpdateOrderChanged">
            <summary>Fired when the UpdateOrder property changes its  value</summary>
        </member>
        <member name="E:Nuclex.Input.InputManager.EnabledChanged">
            <summary>Fired when the Enabled property changes its value</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.TouchPanels">
            <summary>All touch panels known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.UpdateOrder">
            <summary>
              Indicates when the game component should be updated relative to other game
              components. Lower values are updated first.
            </summary>
        </member>
        <member name="P:Nuclex.Input.InputManager.Microsoft#Xna#Framework#IUpdateable#Enabled">
            <summary>Whether the component is currently enabled</summary>
        </member>
        <member name="T:Nuclex.Input.InputManagerTest">
            <summary>Unit tests for the input manager</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestDefaultConstructor">
            <summary>Ensures that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestServiceConstructor">
            <summary>Ensures that the service container constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestKeyboardsCollection">
            <summary>Verifies that the keyboards collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestMiceCollection">
            <summary>Verifies that the mice collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGamePadsCollection">
            <summary>Verifies that the game pads collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestTouchPanelsCollection">
            <summary>Verifies that the touch panels collection isn't empty</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetMouse">
            <summary>Verifies that a mouse can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetKeyboard">
            <summary>Verifies that the main keyboard can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetChatPad">
            <summary>Verifies that a chat pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetXinputGamePad">
            <summary>Verifies that an XINPUT game pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetDirectInputGamePad">
            <summary>Verifies that a DirectInput game pad can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestGetTouchPanel">
            <summary>Verifies that a touch panel can be retrieved</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestSnapshots">
            <summary>Verifies that the snapshot system is working</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestChangeUpdateOrder">
            <summary>Verifies that the UpdateOrder property behaves correctly</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestInitializeGameComponent">
            <summary>
              Verifies that input manager implements the IGameComponent interface
            </summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestEnabledProperty">
            <summary>
              Verifies that input manager provides an enabled property
            </summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.TestUpdateViaIUpdateable">
            <summary>
              Verifies that the input manager can be updated via the IUpdateable interface
            </summary>
        </member>
        <member name="T:Nuclex.Input.InputManagerTest.IUpdateableSubscriber">
            <summary>Subscriber to an updateable object</summary>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.IUpdateableSubscriber.UpdateOrderChanged(System.Object,System.EventArgs)">
            <summary>Called when the updateable's update order has been changed</summary>
            <param name="sender">Updateable who's update order changed</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Input.InputManagerTest.IUpdateableSubscriber.EnabledChanged(System.Object,System.EventArgs)">
            <summary>Called when the updateable is enabled or disabled</summary>
            <param name="sender">Updateable that has been enabled or disabled</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="T:Nuclex.Input.Devices.LeakyQueue`1">
            <summary>Specialized queue which lets users access its raw data</summary>
            <typeparam name="ItemType">Type of items the queue will contain</typeparam>
            <remarks>
              No, it doesn't leak memory. It leaks implementation details. :o)
            </remarks>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.DefaultCapacity">
            <summary>Default capacity a new leaky queue will have</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.GrowFactor">
            <summary>Factor by which the queue grows if its capacity is exceeded</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.MinimumGrow">
            <summary>Minimum number of items the queue will grow by</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.#ctor">
            <summary>Initializes a new leaky queue</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.#ctor(System.Int32)">
            <summary>Initializes a new leaky queue with the specified capacity</summary>
            <param name="capacity">Initial capacity of the leaky queue</param>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.Clear">
            <summary>Removes all items from the queue</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.Contains(`0)">
            <summary>Tests whether the queue contains the specified item</summary>
            <param name="searchedItem">Item the queue will be tested for</param>
            <returns>True if the queue contains the specified item</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.Dequeue">
            <summary>Removes the oldest item from the queue and returns it</summary>
            <returns>The oldest item that was in the queue</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.AdvanceHead">
            <summary>Advances the head index of the queue</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.Enqueue(`0)">
            <summary>Appends an item to the queue</summary>
            <param name="item">Item that will be appended</param>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.AdvanceTail">
            <summary>Advances the tail index of the queue</summary>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.EnsureSlotAvailable">
            <summary>
              Ensures that the is space for at least one more item available
            </summary>
            <remarks>
              Call this before manually inserting an item into the queue
            </remarks>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.Peek">
            <summary>Returns the oldest item in the queue without removing it</summary>
            <returns>The oldest item that is in the queue</returns>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.setCapacity(System.Int32)">
            <summary>Changes the capacity of the queue</summary>
            <param name="capacity">New capacity the queue will assume</param>
        </member>
        <member name="M:Nuclex.Input.Devices.LeakyQueue`1.ToArray">
            <summary>Returns the contents of the queue as an array</summary>
            <returns>A new array containing all items that are in the queue</returns>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.emptyArray">
            <summary>Empty item array to avoid garbage during initialization</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.items">
            <summary>Contains the ring-buffered items stored in the queue</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.headIndex">
            <summary>Index of the queue's head element</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.tailIndex">
            <summary>Index of the queue's tail element</summary>
        </member>
        <member name="F:Nuclex.Input.Devices.LeakyQueue`1.count">
            <summary>Number of items currently contained in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.LeakyQueue`1.Count">
            <summary>Number of items currently stored in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.LeakyQueue`1.HeadIndex">
            <summary>Index of the first item in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.LeakyQueue`1.TailIndex">
            <summary>Index one past the last item in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.Devices.LeakyQueue`1.Items">
            <summary>Returns the internal item array of the queue</summary>
        </member>
        <member name="T:Nuclex.Input.MockInputManager">
            <summary>Manages a set of fake input devices</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.#ctor">
            <summary>Initializes a new mock input manager</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.#ctor(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>Initializs a new mock input manager</summary>
            <param name="services">Game service container the manager registers to</param>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.GetTouchPanel">
            <summary>Returns the touch panel on the system</summary>
            <returns>The system's touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Update">
            <summary>Updates the state of all input devices</summary>
            <remarks>
              <para>
                If this method is called with no snapshots in the queue, it will
                query the state of all input devices immediately, raising events
                for any changed states. This way, you can ignore the entire
                snapshot system if you just want basic input device access.
              </para>
              <para>
                If this method is called while one or more snapshots are waiting in
                the queue, this method takes the next snapshot from the queue and makes
                it the current state of all active devices.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.TakeSnapshot">
            <summary>Takes a snapshot of the current state of all input devices</summary>
            <remarks>
              This snapshot will be queued until the user calls the Update() method,
              where the next polled snapshot will be taken from the queue and provided
              to the user.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetMouse">
            <summary>Returns the primary mouse input device</summary>
            <returns>The primary mouse</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetKeyboard">
            <summary>Returns the keyboard on a PC</summary>
            <returns>The keyboard</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetKeyboard(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the chat pad for the specified player</summary>
            <param name="playerIndex">Player whose chat pad will be returned</param>
            <returns>The chat pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
            <remarks>
              This will only return the XINPUT devices (aka XBox 360 controllers)
              attached. Any standard game pads attached to a PC can only be
              returned through the ExtendedPlayerIndex overload where they will
              take the places of game pads for player 5 and upwards.
            </remarks>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>Returns the game pad for the specified player</summary>
            <param name="playerIndex">Player whose game pad will be returned</param>
            <returns>The game pad of the specified player</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GetTouchPanel">
            <summary>Returns the touch panel on the system</summary>
            <returns>The system's touch panel</returns>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupGamePads">
            <summary>Sets up the collection of available game pads</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupMouse">
            <summary>Sets up the collection of available mice</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupKeyboards">
            <summary>Sets up the collection of available keyboards</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManager.setupTouchPanels">
            <summary>Sets up the collection of available touch panels</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.snapshotCount">
            <summary>Number of state snap shots currently queued</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.gamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.mice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.keyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.touchPanels">
            <summary>Collection of all touch panels known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceGamePads">
            <summary>Collection of all game pads known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceMice">
            <summary>Collection of all mice known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceKeyboards">
            <summary>Collection of all keyboards known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.interfaceTouchPanels">
            <summary>Collection of all touch panels known to the system</summary>
        </member>
        <member name="F:Nuclex.Input.MockInputManager.gameServices">
            <summary>Game service container, saved to unregister on dispose</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.TouchPanels">
            <summary>All touch panels known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.SnapshotCount">
            <summary>Number of snapshots currently in the queue</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#Keyboards">
            <summary>All keyboards known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#Mice">
            <summary>All mice known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#GamePads">
            <summary>All game pads known to the system</summary>
        </member>
        <member name="P:Nuclex.Input.MockInputManager.Nuclex#Input#IInputService#TouchPanels">
            <summary>All touch panels known to the system</summary>
        </member>
        <member name="T:Nuclex.Input.MockInputManagerTest">
            <summary>Unit tests for the fake input device provider</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestDefaultConstructor">
            <summary>Ensures that the default constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestServiceConstructor">
            <summary>Ensures that the service container constructor is working</summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestKeyboardCollection">
            <summary>
              Verifies that the expected number of keyboards are in the keyboards collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestMouseCollection">
            <summary>
              Verifies that the expected number of mice are in the mice collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGamePadCollection">
            <summary>
              Verifies that the expected number of game pads are in the game pads collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestTouchPanelCollection">
            <summary>
              Verifies that the expected number of touch panels are in the touch panel collection
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetMouse">
            <summary>
              Verifies that the mouse can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetKeyboard">
            <summary>
              Verifies that the PC keyboard can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetChatPad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that XBox 360 chat pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetXinputGamePad(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
              Verifies that game pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetDirectInputGamePad(Nuclex.Input.ExtendedPlayerIndex)">
            <summary>
              Verifies that game pads can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestGetTouchPanel">
            <summary>
              Verifies that the touch panel can be retrieved from the input manager
            </summary>
        </member>
        <member name="M:Nuclex.Input.MockInputManagerTest.TestSnapshots">
            <summary>
              Verifies that the snap shot system is working in the mocked input manager
            </summary>
        </member>
        <member name="T:Nuclex.Input.MouseButtons">
            <summary>Available buttons on a mouse</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Left">
            <summary>Left mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Middle">
            <summary>Middle mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.Right">
            <summary>Right mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.X1">
            <summary>First extended mouse button</summary>
        </member>
        <member name="F:Nuclex.Input.MouseButtons.X2">
            <summary>Second extended mouse button</summary>
        </member>
        <member name="T:Nuclex.Input.WindowMessageFilter">
            <summary>Filters window message before they arrive at the XNA window</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.DlgCodeFlags">
            <summary>Flags that will be added to the result of WM_GETDLGCODE</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.#ctor(System.IntPtr)">
            <summary>Initializs the window message filter</summary>
            <param name="windowHandle">Window handle of XNA's game window</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.System#Windows#Forms#IMessageFilter#PreFilterMessage(System.Windows.Forms.Message@)">
            <summary>Filters out a message before it is dispatched</summary>
            <param name="message">
              Message that will be dispatched. You must not modify this message.
            </param>
            <returns>
              True if the message has been processed by the filter and should not be
              dispatched or false to continue processing of the message.
            </returns>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyPressed event</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Fires the KeyReleased event</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnCharacterEntered(System.Char)">
            <summary>Fires the CharacterEntered event</summary>
            <param name="character">Character that has been entered</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnMouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Fires the MouseButtonPressed event</summary>
            <param name="buttons">Mouse buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnMouseButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Fires the MouseButtonReleased event</summary>
            <param name="buttons">Mouse buttons that have been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnMouseMoved(System.Single,System.Single)">
            <summary>Fires the MouseMoved event</summary>
            <param name="x">New X coordinate of the mouse</param>
            <param name="y">New Y coordinate of the mouse</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilter.OnMouseWheelRotated(System.Single)">
            <summary>Fires the MouseWheelRotated event</summary>
            <param name="ticks">Number of ticks the mouse wheel has been rotated</param>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.mouseEventTrackData">
            <summary>
              Provides Informations about how the mouse cusor should be tracked on
              the window to the TrackMouseEvent() function.
            </summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.trackingMouse">
            <summary>True when the mouse cursor is currently being tracked</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.disposed">
            <summary>True when the object has been disposed</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.altKeyDown">
            <summary>Whether the alt key is current being held down</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilter.ctrlKeyDown">
            <summary>Whether the control key is current being held down</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.KeyPressed">
            <summary>Triggered when a key has been pressed down</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.KeyReleased">
            <summary>Triggered when a key has been released again</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.CharacterEntered">
            <summary>Triggered when the user has entered a character</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.MouseButtonPressed">
            <summary>Triggered when a mouse button has been pressed</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.MouseButtonReleased">
            <summary>Triggered when a mouse button has been released</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.MouseMoved">
            <summary>Triggered when the mouse has been moved</summary>
        </member>
        <member name="E:Nuclex.Input.WindowMessageFilter.MouseWheelRotated">
            <summary>Triggered when the mouse wheel has been rotated</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods">
            <summary>Provides access to some P/Invoke-imported native methods</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.DLGC_WANTCHARS">
            <summary>
              Flag returned by a window in response to WM_GETDLGCODE to indicate that it
              is interested in receiving WM_CHAR messages
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.DLGC_WANTALLKEYS">
            <summary>
              Flag returned by a window in response to WM_GETDLGCODE to indicate that it
              wants to process all keyboard input from the user
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TME_LEAVE">
            <summary>
              The caller wants leave notification. Notification is delivered as
              a WM_MOUSELEAVE message.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WM_KEYDOWN_WASDOWN">
            <summary>
              Bit in lparam that indicates whether a WM_KEYDOWN is being generated due
              to the keyboard's auto-repeat
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.HID_USAGE_PAGE_GENERIC">
            <summary>Category for generic HID devices</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.HID_USAGE_GENERIC_MOUSE">
            <summary>Generic HID mouse device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RID_INPUT">
            <summary>Command ID for retrieving input data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_INPUTSINK">
            <summary>
              Enables the caller to receive the input even when the caller is not in
              the foreground. Note that WindowHandle must be specified.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_CAPTUREMOUSE">
            <summary>Mouse button click does not activate the other window</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIDEV_NOLEGACY">
            <summary>Prevents any devices from generating legacy messages</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RIM_TYPEMOUSE">
            <summary>Indicates that the retrieve raw input came from the mouse</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MOUSE_MOVE_RELATIVE">
            <summary>Mouse movement is specified as offset to the last position</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MOUSE_MOVE_ABSOLUTE">
            <summary>Mouse movement is specified in absolute coordinates</summary>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.RegisterRawInputDevices(Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE@,System.Int32,System.Int32)">
            <summary>Registers a raw input device</summary>
            <param name="rawInputDevice">Array of raw input devices</param>
            <param name="deviceCount">Number of devices</param>
            <param name="size">Size of the RAWINPUTDEVICE structure</param>
            <returns>TRUE if successful, FALSE if not</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.GetRawInputData(System.IntPtr,System.Int32,Nuclex.Input.UnsafeNativeMethods.RAWINPUT@,System.Int32@,System.Int32)">
            <summary>Retrieves the raw input from the specified device</summary>
            <param name="rawInputHandle">
              Handle to the raw input structure (provided by WM_INPUT)
            </param>
            <param name="command">Command flag indicating what will be retrieved</param>
            <param name="data">Receives the data that comes from the RAWINPUT structure</param>
            <param name="size">
              Size of the data buffer, receives amount of data retrieved
            </param>
            <param name="headerSize">Size, in bytes, of the RAWINPUTHEADER structure</param>
            <returns>
              If pData is NULL and the function is successful, the return value is 0.
              If pData is not NULL and the function is successful, the return value is
              the number of bytes copied into pData. -1 on error.
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.TrackMouseEvent(Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT@)">
            <summary>
              Posts messages when the mouse pointer leaves a window or hovers over a window
              for a specified amount of time
            </summary>
            <param name="eventTrack">
              Pointer to a TRACKMOUSEEVENT structure that contains tracking information
            </param>
            <returns>If the function succeeds, the return value is nonzero</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.MapVirtualKey(System.UInt32,System.UInt32)">
            <summary>
              Translates (maps) a virtual-key code into a scan code or character value,
              or translates a scan code into a virtual-key code
            </summary>
            <param name="code">Virtual-key code or scan code for a key</param>
            <param name="mapType">Translation to perform</param>
            <returns>
              A scan code, virtual key code or character value depending on
              the translation peformed. Zero if no translation could be performed.
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.PostMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
              Places (posts) a message in the message queue associated with the thread that
              created the specified window and returns without waiting for the thread to
              process the message.
            </summary>
            <param name="windowHandle">
              Handle to the window whose window procedure is to receive the message
            </param>
            <param name="messageId">Specifies the message to be posted</param>
            <param name="wParam">Specifies additional message-specific information</param>
            <param name="lParam">Specifies additional message-specific information</param>
            <returns></returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.SendMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Sends the specified message to a window or windows</summary>
            <param name="windowHandle">
              Handle to the window whose window procedure will receive the message
            </param>
            <param name="messageId">Specifies the message to be sent</param>
            <param name="wParam">Specifies additional message-specific information</param>
            <param name="lParam">Specifies additional message-specific information</param>
            <returns>Depends on the message being sent</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.PostThreadMessage(System.Int32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>Posts a message to the message queue of the specified thread</summary>
            <param name="threadId">
              Identifier of the thread to which the message is to be posted
            </param>
            <param name="messageId">Type of message that will be posted</param>
            <param name="wParam">Additinal message-specified information</param>
            <param name="lParam">Additinal message-specified information</param>
            <returns>If the function succeeds, the return value is nonzero</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.LoadLibrary(System.String)">
            <summary>
              Loads the specified module into the address space of the calling process
            </summary>
            <param name="filename">Name of the module that will be loaded</param>
            <returns>
              If successful, the handle of the loaded module, otherwise NULL
            </returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.FreeLibrary(System.IntPtr)">
            <summary>
              Frees the loaded dynamic-link library (DLL) module and, if necessary,
              decrements its reference count
            </summary>
            <param name="moduleHandle">A handle to the loaded library module</param>
            <returns>Any non-zero value on success, otherwise zero</returns>
        </member>
        <member name="M:Nuclex.Input.UnsafeNativeMethods.TranslateMessage(System.Windows.Forms.Message@)">
            <summary>Translates virtual-key messages into character messages</summary>
            <param name="message">Keyboard Message that will be translated</param>
            <returns>
              True if the message has been translated into a character message that
              has been posted to the thread's message queue
            </returns>
            <remarks>
              The character messages are posted to the calling thread's message queue,
              to be read the next time the thread calls the GetMessage() or
              PeekMessage() function.
            </remarks>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.MapTypes">
            <summary>Translation to perform</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeyToScanCode">
            <summary>
              Virtual-key code is translated into a scan code. Does not distinguish
              between left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.ScanCodeToVirtualKey">
            <summary>
              Scan code is translated into a virtual-key code that does not distinguish
              between left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeyToChar">
            <summary>
              Virtual-key code is translated into an unshifted character value
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.ScanCodeToVirtualKeyEx">
            <summary>
              Scan code is translated into a virtual-key code that distinguishes between
              left- and right-hand keys.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.MapTypes.VirtualKeytoScanCodeEx">
            <summary>
              Virtual-key code is translated into a scan code. Distinguishes between
              left- and right-hand keys.
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.WindowMessages">
            <summary>List of window message relevant to the input capturer</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_GETDLGCODE">
            <summary>Sent to a window to ask which types of input it processes</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_INPUT">
            <summary>Transmits raw input data to the window</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_KEYDOWN">
            <summary>Indicates that the user has pressed a key on the keyboard</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_KEYUP">
            <summary>Indicates that the user has released a key on the keyboard</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_CHAR">
            <summary>Indicates that the user has entered text</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_UNICHAR">
            <summary>Indicates that the user has entered text (UTF-32 variant)</summary>
            <remarks>
              This is only required if the window is an ANSI window (created by
              CreateWindowA() and not reset to unicode). In this case, windows will
              send WM_CHAR with ANSI characters and WM_UNICHAR with UTF-32 characters.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEMOVE">
            <summary>Indicates that the mouse cursor has been moved</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONDOWN">
            <summary>Indicates that the left mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONUP">
            <summary>Indicates that the left mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_LBUTTONDBLCLK">
            <summary>Indicates that the left mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONDOWN">
            <summary>Indicates that the right mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONUP">
            <summary>Indicates that the right mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_RBUTTONDBLCLK">
            <summary>Indicates that the right mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONDOWN">
            <summary>Indicates that the middle mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONUP">
            <summary>Indicates that the middle mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MBUTTONDBLCLK">
            <summary>Indicates that the middle mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEHWHEEL">
            <summary>Indicates that the mouse wheel has been rotated</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONDOWN">
            <summary>Indicates that an extended mouse button was pressed down</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONUP">
            <summary>Indicates that an extended mouse button was released again</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_XBUTTONDBLCLK">
            <summary>Indicates that an extended mouse button was double-clicked</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSEHWHEEL_TILT">
            <summary>Indicates that the mouse wheel has been rotated or tilted</summary>
            <remarks>
              This window message is only supported by Windows Vista. Mouse drivers may,
              however, emulate it on Windows XP by directly communicating with
              the low-level driver and injecting this message into the active window.
            </remarks>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.WindowMessages.WM_MOUSELEAVE">
            <summary>Sent to the window when the mouse cursor has left it</summary>
            <remarks>
              To receive this message, the window has to set up the notification using
              the TrackMouseEvent() function when the mouse enters the window.
            </remarks>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE">
            <summary>Identifies a raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.UsagePage">
            <summary>Top level collection Usage page for the raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.Usage">
            <summary>Top level collection Usage for the raw input device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.Flags">
            <summary>
              Mode flag that specifies how to interpret the information provided
              by UsagePage and Usage
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTDEVICE.WindowHandle">
            <summary>
              Handle to the target window. If NULL it follows the keyboard focus
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT">
            <summary>
              Used by the TrackMouseEvent function to track when the mouse pointer leaves
              a window or hovers over a window
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.structureSize">
            <summary>The size of the TRACKMOUSEEVENT structure</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.flags">
            <summary>Specifies the services requested</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.trackWindowHandle">
            <summary>Specifies a handle to the window to track</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.TRACKMOUSEEVENT.hoverTime">
            <summary>
              Specifies the hover time-out (if TME_HOVER was specified in dwFlags),
              in milliseconds
            </summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER">
            <summary>Header information that is part of the raw input data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Type">
            <summary>Type of device the input is coming from.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Size">
            <summary>Size of the packet of data.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.Device">
            <summary>Handle to the device sending the data.</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUTHEADER.wParam">
            <summary>wParam from the window message.</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE">
            <summary>
            Value type for raw input from a mouse.
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.Flags">
            <summary>Specifies what kind of data is being transmitted</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ButtonData">
            <summary>
              If the mouse wheel is rotated, this will contain the delta amount
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ButtonFlags">
            <summary>State transition of the mouse buttons</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.RawButtons">
            <summary>Raw state of the mouse buttons</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.LastX">
            <summary>Position or offset in X direction, depending on the flags</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.LastY">
            <summary>Position or offset in Y direction, depending on the flags</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWMOUSE.ExtraInformation">
            <summary>Additional device-specific informations about the event</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWHID">
            <summary>
              Describes the format of the raw input from a Human Interface Device
            </summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Size">
            <summary>Size, in bytes, of the HID data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Count">
            <summary>Number of HID inputs contained in the data</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWHID.Data">
            <summary>Raw input data as an array of bytes</summary>
        </member>
        <member name="T:Nuclex.Input.UnsafeNativeMethods.RAWINPUT">
            <summary>Contains the raw input from a device</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.Header">
            <summary>Describes the data contained in the event</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.Mouse">
            <summary>Contains mouse-specific data if this is a mouse event</summary>
        </member>
        <member name="F:Nuclex.Input.UnsafeNativeMethods.RAWINPUT.HID">
            <summary>Contains generic input data if this is an HID</summary>
        </member>
        <member name="T:Nuclex.Input.WindowMessageFilterTest">
            <summary>Unit tests for the window message interceptor</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.Setup">
            <summary>Called once before each test is run</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.Teardown">
            <summary>Called once after each test has run</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestConstructor">
            <summary>Verifies that the constructor of the interceptor is working</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestKeyPressMessage">
            <summary>Verifies that the WM_KEYDOWN message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestKeyReleaseMessage">
            <summary>Verifies that the WM_KEYDOWN message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestCharacterEnteredMessage">
            <summary>Verifies that the WM_CHAR message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestMouseMoveMessage">
            <summary>Verifies that the WM_MOUSEMOVE message is intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestMouseButtonPressedMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,Nuclex.Input.MouseButtons)">
            <summary>Verifies that the WM_*BUTTONDOWN messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestMouseButtonReleasedMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,Nuclex.Input.MouseButtons)">
            <summary>Verifies that the WM_*BUTTONUP messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestMouseWheelMessage">
            <summary>Verifies that WM_MOUSEWHEEL messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.TestMouseLeaveMessage">
            <summary>Verifies that WM_MOUSELEAVE messages are intercepted</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.sendThreadMessage(Nuclex.Input.UnsafeNativeMethods.WindowMessages,System.Int32,System.Int32)">
            <summary>Sends a message to the game's window</summary>
            <param name="message">Message that will be sent</param>
            <param name="wParam">Value for the message's wParam</param>
            <param name="lParam">Value for the message's lParam</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.mockMouseSubscriber">
            <summary>
              Mocks a mouse message subscriber and registers it to the interceptor's events
            </summary>
            <returns>The new mouse message subscriber</returns>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.mockKeyboardSubscriber">
            <summary>
              Mocks a keyboard message subscriber and registers it to the interceptor's events
            </summary>
            <returns>The new keyboard message subscriber</returns>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilterTest.MouseButtonDownMessage">
            <summary>Called when a mouse button has been pressed</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilterTest.MouseButtonUpMessage">
            <summary>Called when a mouse button has been released</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilterTest.form">
            <summary>Form used to test interception of window messages</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilterTest.filter">
            <summary>Message interceptor for the form</summary>
        </member>
        <member name="F:Nuclex.Input.WindowMessageFilterTest.mockery">
            <summary>Creates dynamic mock objects based on interfaces</summary>
        </member>
        <member name="T:Nuclex.Input.WindowMessageFilterTest.IKeyboardMessageSubscriber">
            <summary>Subscriber to keyboard messages arriving at the window</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IKeyboardMessageSubscriber.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key is pressed on the keyboard</summary>
            <param name="key">Key that has been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IKeyboardMessageSubscriber.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>Called when a key on the keyboard has been released</summary>
            <param name="key">Key that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IKeyboardMessageSubscriber.CharacterEntered(System.Char)">
            <summary>Called when the user has entered a character</summary>
            <param name="character">Character the user has entered</param>
        </member>
        <member name="T:Nuclex.Input.WindowMessageFilterTest.IMouseMessageSubscriber">
            <summary>Subscriber to mouse messages arriving at the window</summary>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IMouseMessageSubscriber.MouseButtonPressed(Nuclex.Input.MouseButtons)">
            <summary>Called when a mouse button has been pressed</summary>
            <param name="buttons">Buttons that have been pressed</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IMouseMessageSubscriber.MouseButtonReleased(Nuclex.Input.MouseButtons)">
            <summary>Called when a button on the mouse has been released</summary>
            <param name="buttons">Button that has been released</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IMouseMessageSubscriber.MouseMoved(System.Single,System.Single)">
            <summary>Called when the mouse cursor has been moved</summary>
            <param name="x">New X coordinate of the mouse cursor</param>
            <param name="y">New Y coordinate of the mouse cursor</param>
        </member>
        <member name="M:Nuclex.Input.WindowMessageFilterTest.IMouseMessageSubscriber.MouseWheelRotated(System.Single)">
            <summary>Called when the mouse wheel has been rotated</summary>
            <param name="ticks">Number of ticks the mouse wheel was rotated</param>
        </member>
    </members>
</doc>
